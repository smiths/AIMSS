\documentclass[letterpaper, cleveref]{lipics-v2019}

\usepackage{natbib}
\usepackage{booktabs}
\usepackage{amsmath,amsthm}
\usepackage{hyperref}
\hypersetup{
colorlinks=true,        % false: boxed links; true: colored links
linkcolor=blue,         % color of internal links (change box color with linkbordercolor)
citecolor=blue,         % color of links to bibliography
filecolor=magenta,      % color of file links
urlcolor=cyan           % color of external links
}
\usepackage{bbding}
\usepackage{tcolorbox}

% new tcolorbox environment
% #1: tcolorbox options
\newtcolorbox{mybox}[1][]
{
  colframe = yellow!50!red,
  colback  = white,
  width=\dimexpr\textwidth+12mm\relax,
  enlarge left by=-6mm,
  #1,
}

%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}} %Spencer Smith
\newcommand{\jc}[1]{\authornote{red}{JC}{#1}} %Jacques Carette
\newcommand{\oo}[1]{\authornote{magenta}{OO}{#1}} %Olu Owojaiye
\newcommand{\pmi}[1]{\authornote{green}{PM}{#1}} %Peter Michalski
\newcommand{\ad}[1]{\authornote{cyan}{AD}{#1}} %Ao Dong

\newcommand{\notdone}[1]{\textcolor{red}{#1}}
\newcommand{\done}[1]{\textcolor{black}{#1}}

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\title{Quality Definitions of Qualities} 
\author{Spencer Smith}{McMaster University, Canada}{smiths@mcmaster.ca}{}{}
\author{Jacques Carette}{McMaster University, Canada}{carette@mcmaster.ca}{}{}
\author{Olu Owojaiye}{McMaster University, Canada}{owojaiyo@mcmaster.ca}{}{}
\author{Peter Michalski}{McMaster University, Canada}{michap@mcmaster.ca}{}{}
\author{Ao Dong}{McMaster University, Canada}{donga9@mcmaster.ca}{}{}

\authorrunning{Smith et al.}  \Copyright{Spencer Smith and Jacques Carette and
Olu Owojaiye and Peter Michalski and Ao Dong}

\date{\today}

\hideLIPIcs
\nolinenumbers

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007</concept_id>
<concept_desc>Software and its engineering</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering}

\keywords{software qualities, installability, correctness, verfiability,
  validatability, testability, reliability, robustness, performance,
  usability, maintainability, reusability, portability, understandability,
  interoperability, visibility/transparency, reproducibility, productivity,
  sustainability, completness, consistency, modifiability, traceability,
  unambiguity, verifiability, abstract}

\begin{document}
\maketitle

\begin{abstract}
	We have found some of the existing definitions of software qualities
	inadequate as a basis for conducting and presenting our software engineering
	research.  Therefore, we have endeavored to create a list of definitions that
	are consistent (same words/phrases are always used for the same concepts),
	measurable (all qualities are conceptually measurable, even if the data needed
	for measurement is often unavailable), abstract (quality definitions state
	what the quality achieves, but not how to achieve it) and traceable (explicit
	links are given to all previous definitions and the ideas within those
	definitions).  Our methodology starts with an exhaustive literature survey to
	find existing definitions.  We then determine the recommended definition,
	which is either one of the existing definitions, or a new definition, found by
	combining existing definitions.  Each recommended definition is accompanied by
	a rationale that explicitly justifies the definition.  By presenting the
	rationales, we hope our software engineering colleagues will scrutinize our
	work and provide recommendations for future modifications. The qualities that
	are defined include installability, correctness, reliability, robustness,
	performance, usability, verifiability, validatability, testability,
	maintainability, reusability, portability, understandability,
	interoperability, productivity, visibility/transparency, reproducibility,
	sustainability, completeness, consistency, modifiability, traceability,
	unambiguity and abstract.  Each quality is classified into one or more of the
	following categories: direct, indirect, internal, external, product or
	process.
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Introduction} \label{SecIntroduction}

In the course of conducting and presenting our software engineering related
research we have often desired clear definitions for relevant software
qualities, like maintainability, usability, productivity, sustainability, etc.
Unfortunately, the definitions of qualities that we have found in the literature
are not always satisfying.  This inadequacy of existing definitions became
particularly clear when we recently undertook an exercise measuring the
\lq\lq{}state of the practice\rq\rq{} in different software domains, including
the domains of seismology software \citep{SmithEtAl2018}, Geographic Information
Systems \citep{SmithEtAl2018_arXivGIS} and mesh generators
\citep{smith2016state}. When determining methods to quickly assess quality
across large samples of existing software, we found communication amongst
ourselves and with others challenging. We craved unambiguous and standardized
definitions to enable and inspire methods for measuring software qualities.  To
help ground our future research, and possibly help others in the same situation,
we have collected an exhaustive list of definitions.  From this list we have
produced our set of recommended software quality definitions.  

In the current work, software is defined as either programs, which run (execute)
on a computer, or libraries, which provide services to be used by programs. Both
programs and libraries are created using computer code, written in a programming
language.

Quality is defined as a measure of the excellence or worth of an entity.  As is
standard practice, we do not think of quality as a single measure, but rather as
a set of measures.  That is, quality is a collection of different qualities,
often called ``ilities.''  In the overview of managing software quality provided
by \citet[p.~110]{VanVliet2000} the different measures are called quality
attributes, quality factors, and quality criteria.  In \citet{ISO9126} they are
called quality characteristics, sub-characteristics and attributes.  To keep our
presentation simple, and to not imply a classification hierarchy that we don't
intend, we will just use the term qualities to refer to the different measures
of quality.

The qualities of most interest to project managers and users are summarized in
the next subsection (Section~\ref{Sec_IndirectQualities}).  Since these
qualities cannot generally be measured directly, they are characterized as
indirect qualities. The relevant indirect qualities are listed in this section
and each quality is grouped into one or more of the following categories:
external, internal, product or process. The next subsection lists the relevant
direct qualities that assist in achieving the indirect qualities.  The final
subsection presents the methodology that was employed to summarize, analyze and
define each quality.

\subsection{Indirect Qualities} \label{Sec_IndirectQualities}

Many taxonomies have been proposed for software qualities, as in
\citet{McCallEtAl1977, boehm1976quantitative, ISO9126}. Rather than aiming for
complete coverage of the history of qualities, the wide variety of potential
qualities, or the relationships between them, we will instead take a practical
approach; we will focus on the qualities that we have found most relevant in our
research.  This means we will include the usual software engineering suspects,
like usability and maintainability.  Since we also do research on scientific
computing software, we will also include scientifically relevant qualities, like
validatability and reproducibility.

Given our respect for \citet[p.\ 15--33]{GhezziEtAl2003}, we used their list of
qualities as a starting point. Our list, shown in
Table~\ref{Tab_SoftwareQualities}, includes all of their qualities, except for
timeliness, which was excluded because the already included quality of
productivity sufficiently overlaps with timeliness.  To the list from
\citet{GhezziEtAl2003} we have added the practical quality of installability,
since our aforementioned studies on the state of the practice in different
software domains (for instance \citet{SmithEtAl2018_arXivGIS}) have shown us
that none of the other qualities matter if the software cannot be properly
installed.  Given our interest in scientific computing, we also added the
qualities of validatability and reproducibility. Since we found few definitions
in the literature on the quality of verifiability, we also added the closely
related quality of testability.  The quality of sustainability was added since
this term has emerged as a popular goal for software projects.

The order of the qualities in Table~\ref{Tab_SoftwareQualities} follow the order
used in \cite{GhezziEtAl2003}, which puts related qualities (like correctness
and reliability) together.  Moreover, the order is roughly the order in which
qualities are considered in practice.  We followed these same guidelines when
inserting our additional qualities into the list.

\begin{table}[h!]
  \begin{center}
  \begin{tabular}{lllll}
  \toprule
  & External & Internal & Product & Process \\  
  \midrule
  Installability & \Checkmark & & \Checkmark & \\
  Correctness & \Checkmark & \Checkmark & \Checkmark & \Checkmark \\
  Reliability & \Checkmark & & \Checkmark & \Checkmark \\
  Robustness & \Checkmark & & \Checkmark & \Checkmark \\     
  Performance & \Checkmark & & \Checkmark & \\
  Usability & \Checkmark & & \Checkmark & \Checkmark \\
  Verifiability & & \Checkmark & \Checkmark & \Checkmark \\
  Validatability & \Checkmark & & \Checkmark & \Checkmark\\     
  Testability & & \Checkmark & \Checkmark & \\
  Maintainability &  & \Checkmark & \Checkmark & \Checkmark\\
  Reusability & & \Checkmark & \Checkmark & \Checkmark\\
  Portability & & \Checkmark & \Checkmark & \\
  Understandability & & \Checkmark & \Checkmark & \\     
  Interoperability & \Checkmark & & \Checkmark & \\
  Productivity &  &  &  & \Checkmark \\
  Visibility &  & &  & \Checkmark \\
  Reproducibility & \Checkmark & & \Checkmark & \\
  Sustainability & & \Checkmark & \Checkmark & \\      
  \bottomrule
\end{tabular}
\end{center}
\caption{Software Qualities}
\label{Tab_SoftwareQualities}
\end{table}

Table~\ref{Tab_SoftwareQualities} makes a distinction between external and
internal qualities.  External qualities are the qualities that are relevant to
the user of the software while internal qualities are those that are relevant to
developers \citep[p.\ 16]{GhezziEtAl2003}.  Although the users are not typically
interested in internal qualities, it is the internal qualities that influence
external quality.  External qualities are assessed using the produced software
and any user relevant documentation.  Internal qualities reference such things
as the code, documentation, test cases, and the software development process.
Correctness is shown as both an internal and external quality because it is
possible to judge the correctness of software and to judge the correctness of
the various internal artifacts produced while developing the software.  The
external quality of reliability is influenced by the internal quality of
verifiability. Since validatability is related to getting the right
requirements, it is shown as an external quality.  Although one could judge the
usability of internal documentation, the quality of usability is considered as
external, since the quality of understandability designated to cover the internal
equivalent of usability.

Some qualities focus on the product, others on the process, and yet others on
both, as shown in Table~\ref{Tab_SoftwareQualities}.  The term product refers to
both the external and internal products.  The external products are the
user-visible products, like the software itself and any user documentation.  The
internal products are the products (sometimes called work products or artifacts)
relevant to the developers, like requirements documentation, design
documentation, test cases, makefiles, etc.  The process refers to the sequence
of activities that produce the software.  The process generates both the
internal and external products.  The process is based on principles, methods and
techniques while being supported by tools.  All product qualities (internal and
external) are effected by the process, so the checkmarks in
Table~\ref{Tab_SoftwareQualities} are used for a different purpose.  The
checkmarks show which qualities are applied to the process itself.  For
instance, we can consider the correctness and maintainability of a process, but
discussing the portability of a process makes little sense. Rather than apply
the quality of performance to a process, we instead introduce the process
specific quality of productivity.  Although we can imagine discussing the
understandability of a process, to avoid confusion and overlap, we reserve
understandability for the internal quality applied to products (like code). For
the related process quality, we designate the term usability.

The qualities shown in Table~\ref{Tab_SoftwareQualities} are qualities that can
only be measured indirectly \citep[p.\ 109]{VanVliet2000}.  For instance, a
direct measure of maintainability doesn't exist.  Since it cannot be measured
directly, we base our estimation of maintainability on direct measures that are
likely to influence maintainability, like consistency, traceability, etc.
Qualities that can be measured directly are discussed in the next section.

\subsection{Direct Qualities} \label{SecDirectQsIntro}

To achieve the qualities listed in Section~\ref{Sec_IndirectQualities},
conventional wisdom holds that the internal products should aim for the
qualities listed in this section.  All but the final quality listed
(abstraction), are adapted from the IEEE recommended practice for producing good
software requirements \citep{IEEE1998}. Abstraction is an important addition
because it is the software development principle that allows us to deal with
complexity \citep[p.~40]{GhezziEtAl2003}. \citet{IEEE1998} also includes
correctness and verifiability, but we have excluded these from our list, since
they belong in the list of indirect qualities in the previous section.

\begin{itemize}
  \item Completeness
  \item Consistency
  \item Modifiability
  \item Traceability
  \item Unambiguity
  \item Abstract
\end{itemize}

All of the direct qualities listed above are internal qualities.  Furthermore,
they apply to both the (internal) product and the process.

\subsection{Methodology} \label{SecMethodology}

For each quality we collect as many distinct instances of the definition that we
can find.  Some of the definitions occur in multiple places (for instance the
definitions from \citet{McCallEtAl1977} appear in many software engineering
textbooks).  Since these instances do not add any new information, they are not
included; we do not make an effort to identify how frequently the definitions
reappear in different sources.  Once all the definitions are collected, we
determine the definition that we would like to recommend.  The recommended
definition can either be our preference from the existing definitions, or a new
definition, which is often found by combining existing definitions.  

To ensure that our recommended definitions are quality definitions, they are
based on the direct quality measures (Section~\ref{SecDirectQsIntro}).  To the
list of direct qualities, we also add the quality criteria of measurability.
How the direct qualities are applied to develop quality definitions of qualities
is described below.

\begin{description}

  \item[Completeness] To judge the completeness of our definitions, we verify
  that all of the relevant points from the collected definitions have been
  included, or explicitly rejected in the definition's rationale.  We also
  verify that all facets of the definition are covered when a quality applies to
  multiple categories of internal, external, product and/or process.  Finally,
  we check that all of the qualities listed in this section have been
  considered.
  
  \item[Consistency] The final list of definitions should be consistent in the
  terminology used.  For instance, we do not use synonyms; we use
  the same word or phrase to mean the same concept throughout the final list of
  definitions.  Specific decisions on terminology are as follows:
  \begin{itemize}
    \item To represent the idea of cost, effort, time, resources, and
    efficiency, we say \emph{effort}.
    \item To represent ``the degree to which'' or the ``the extent to which'',
    we will say \emph{the extent to which}.
    \item \wss{Fill in additional consistency decisions, as we go through
    definitions.}
  \end{itemize}

  \item[Modifiability] The modifiability of the definitions is aided by the fact
  that the definitions are short.  Changes are not difficult to make.  The
  modifiability is further aided by the related qualities of traceability and
  abstraction.

  \item[Traceability] Each definition includes a section for the rationale.  The
  rationale explicitly links the recommended definition to the previously
  published definitions.  The rationale also explains why any aspects of the
  previous definitions were ignored.  The rationale also explicitly traces the
  selected definition to the qualities in this section.

  \item[Unambiguity] With natural language it is difficult to remove all
  ambiguity, but every effort is made to keep the definitions simple and to use
  standard and consistent terminology.  The rationale given for each recommended
  definition also serves the purpose of making the definitions unambiguous.

  \item[Abstract] Quality definitions should say what the quality achieves, but
  not how to achieve it.  We aim for abstract definitions that do not assume any
  specific methodology or tools.  For those qualities that fit into multiple
  categories of internal, external, product and/or process, we aim to have one
  definition that will apply to all.  When that is not possible, we will clarify
  how the definition is modified between categories.

  \item[Measurability] Although many qualities can only be indirectly measured,
  the definition of the quality should imply a measure that is conceptually
  possible, even if the data needed to complete the measurement is often
  unavailable.  The scale type of the units of measure are as follows, in order
  of preference: ratio, interval, ordinal and nominal.  These scale types are
  defined in \citet[p.\ 107]{VanVliet2000}.  The ratio and interval scale types
  are preferred to the ordinal and nominal types because they can convey more
  information.  Specific consequences of aiming for measurability are as
  follows:
  \begin{itemize}
    \item We will avoid the common phrase in definitions of ``the capability
    of'' because this implies a binary measure.  By this definition a product
    (or process) is either capable or not; it is a binary measure.  Instead of
    measuring capability, we will prefer to use the phrase ``the effort
    required''.
    \item \wss{Add to this list as measurability specific decisions are made.}
  \end{itemize}
   
\end{description}

Our aim is to capture the essence of the quality in an unambiguous way, even if
it cannot be measured. This is analogous to the definition of true error in
scientific computing.  The true error, which is the difference between the
calculated and the true solution, can rarely be calculated since the true
solution is generally unknown. Even though true error can only be estimated, the
concept of true error is integral to analyzing and understanding the behaviour
of numerical algorithms.

After completing each definition we verify that the definition works for all of
the quality categories (internal, external, product and process) that apply.  If
not, the definition is modified.  The rationale section is written to explicitly
addresses each of these points.  Each definition is also checked to verify that
it is complete, consistent, traceable, unambiguous, abstract and measurable.
The rational section is written to explain how these qualities, for each quality
definition, are achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Indirect Qualities of Software, Artifacts and Processes}
\label{SecQualities}

The presentation below for each of the qualities is the same.  First, we
summarize, in the order of their publication, all of the definitions that we
could find in the literature.  To keep the clutter of quotation marks down, we
have adopted the convention that each definition is given verbatim from the
cited source, but without showing quotation marks.  In cases where the
definition has to be rephrased, quotation marks are used to show those portions
that are taken verbatim for the original source.  Second, after the summary of
the existing definitions, we propose the definition that we would like to work
with going forward. Third, following the proposed definition is an explanation
for the reasoning that led to this choice.  The definitions apply to internal,
external, product and process following the designations in
Table~\ref{Tab_SoftwareQualities}. Where necessary, this is clarified in the
definition and its rationale.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Installability (external, product)} %\oo{owner}

\begin{defn} \label{Installability_ISO9126}
  The capability of the software product to be installed in a specified
  environment \citep{ISO9126}. %2001
\end{defn}

\begin{defn} \label{Installability_Selected2}
	The degree of effectiveness and efficiency with which a product or system can
	be successfully installed and/or uninstalled in a specified environment
	\citep{ISO/IEC25010}. %2011
\end{defn}

\begin{defn} \label{Installability_Selected1} Installability refers to the cost
  or effort required for the installation, given an installation is possible to
  begin with \citep{lenhard2013measuring}.
\end{defn}

\begin{mybox}
\subsubsection*{Installability} 

The effort required for the installation and/or uninstallation of software in a
specified environment.

\end{mybox}

\subsubsection*{Reasoning}

The recommended definition comes from combining
Definitions~\ref{Installability_Selected2} and \ref{Installability_Selected1}.
The rationales for the proposed definition are as follows:

\begin{itemize}
  \item For consistency we use the term \textbf{effort} in place of efficiency.
  \item The ``effectiveness'' from Definition~\ref{Installability_Selected2} is
  dropped because the success or failure of an installation is typically judged
  as a binary result.  The installation is generally either completed, or not.
  \item Although we are okay with a binary result for success or failure of an
  installation, the measure of effort required to complete an installation is
  not a binary measure.  For this reason, we do not use the term ``the
  capability of'' (from Definition~\ref{Installability_ISO9126}), so that we can
  be consistent with our other recommended definitions where we avoid that term
  for measurability reasons.
  \item From Definition~\ref{Installability_Selected1} the phrase ``given an
  installation is possible to begin with'' is removed because this notion is
  covered by the measure of effort.  The effort will be infinite if an
  installation is impossible.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 \subsection{Correctness (external, internal, product, process)} %\oo{owner}

\begin{defn} \label{Correctness_McCallEtAl1977}
  The extent to which a program satisfies its specifications and fulfills the
  user's mission objectives \citep{McCallEtAl1977}. 
\end{defn}

\begin{defn} \label{Correctness_meyer1988object}
  The ability of software products to perform their exact tasks, as defined by
  their specification \citep{meyer1988object}.
\end{defn}

\begin{defn} \label{Correctness_IEEEComputerDictionary1991}
  The degree to which a system or component is free from faults in its
  specification, design and implementation \citep{IEEEComputerDictionary1991}.
\end{defn}

\begin{defn} \label{Correctness_GhezziEtAl2003}
  A program is functionally correct if it behaves according to its stated
  functional specifications \citep{GhezziEtAl2003}.  	
\end{defn}

\begin{defn} \label{Correctness_mcconnell2004code}
  The degree to which a system is free from faults in its specification, design,
  and implementation \citep{mcconnell2004code}.
\end{defn}

\begin{mybox}
\subsubsection*{Correctness}
An entity is correct if it matches its specification.  The entity can be either
software, an internal product (work product or artifact) or process.  The
specification can either be explicitly stated or implicit.
\end{mybox}

\subsubsection*{Reasoning}

The selection definition is a rephrasing of
Definition~\ref{Correctness_GhezziEtAl2003}.  All of the other definitions
(Definition~\ref{Correctness_McCallEtAl1977},
Definition~\ref{Correctness_meyer1988object},
Definition~\ref{Correctness_IEEEComputerDictionary1991} and
Definition~\ref{Correctness_mcconnell2004code}) also mention specification.  The
rationale for the proposed definition follows:

\begin{itemize}
  \item Definition~\ref{Correctness_McCallEtAl1977} mentions ``mission
  objectives''.  We feel that the mission objectives are incorporated into the
  specification, so this element is not need to be mentioned separately in the
  recommended definition.
  \item Definition~\ref{Correctness_GhezziEtAl2003} refers to the functional
  specification, but we believe that correct software also follows the
  nonfunctional specification.  For instance, for safety critical software the
  performance requirements need to be satisfied, or the software will not be
  trustworthy and therefore not correct.
  \item Definition~\ref{Correctness_IEEEComputerDictionary1991} and
  Definition~\ref{Correctness_mcconnell2004code} are almost the same, except
  Definition~\ref{Correctness_IEEEComputerDictionary1991} mentions ``system or
  component'' rather than just ``system''.  To keep our recommended definition
  simple, we do not introduce the distinction of components; we just focus on
  the entities of the software, internal products and processes.
  \item Several of the previous definitions imply measurement of different
  levels of correctness by phrases such as ``The extent to which''
  (Definition~\ref{Correctness_McCallEtAl1977}) and ``The degree to which''
  (Definitions~\ref{Correctness_IEEEComputerDictionary1991}
  and~\ref{Correctness_mcconnell2004code}). However, the proposed definition has
  a binary range of possible measurement -- either correct or incorrect.  This
  doesn't follow our stated goal (in Section~\ref{SecMethodology}) of having the
  quality of measurement cover the largest possible scale type.  Like the
  recommended definition,
  Definition~\ref{Correctness_IEEEComputerDictionary1991} also implies a binary
  measure with the phrase ``the ability of''.  Making correctness a binary
  quality makes the definition unambiguous and it frees up room for the quality
  of reliability to cover the more nuanced aspects of how an entity is
  ``correct''.
  \item Like the recommended definition,
  Definition~\ref{Correctness_IEEEComputerDictionary1991} implies that
  correctness can be judged for products.
  Definition~\ref{Correctness_IEEEComputerDictionary1991} mentions the
  ``specification, design and implementation''.
  \item So that our definition of correctness can be abstract and thus also
  apply to internal products, the definition mentions internal products, and
  states that the specification can be implicit.  To be correct an internal
  product needs to follow any specified template or documentation conventions.
  Moreover, although they may not be stated explicitly, the requirements for a
  document will be implicitly specified in the minds of the products
  authors/creators.
  \item So that our definition of correctness can be abstract and thus also
  apply to processes, the definition mentions processes and states the
  specification can be implicit.  If the rules of the process are explicitly
  specified, then developers can check whether the rules have been followed.
  Even when the rules are not stated in writing, the developers will have
  implicit (possibly changing and inconsistent) rules in their minds.
  \item The definition for correctness allows the specification to be implicit,
  even for the external product of the software itself.  Not every project
  writes down the requirements, but the requirements still exist inside the
  heads of the developers.  This is why testing can be done for software, even
  when the developers do not specify their requirements.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Reliability (external, product, process)}} %\oo{owner} %NOTDONE

\begin{defn}
  Code possesses the characteristic reliability to the extent that it can be
  expected to perform its intended functions satisfactorily
  \citep{boehm1976quantitative}.
\end{defn}

\begin{defn}
  Extent to which a program can be expected to perform its intended function
  with required precision \citep{McCallEtAl1977}.
\end{defn}

\begin{defn} \label{reliabilitySelected1} It is the probability of failure-free
  operation of a computer program in a specified environment for a specified
  time \citep{musa1987software}.
\end{defn}

\begin{defn}
  The ability of a system or component to perform its required function under
  stated conditions for a specified period of time
  \citep{IEEEComputerDictionary1991}.
\end{defn}

\begin{defn}
 The capability of the software product to maintain a specified level of
 performance when used under specified conditions \cite{ISO9126}. %2001
\end{defn}

\begin{defn}
  Informally, software is reliable if the user can depend on it
  \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn} \label{reliabilitySelected2} Reliability is concerned with
	measuring the probability of occurrence of failure - that is, the probability
	of the observable effects of errors \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
  The ability of a system to perform its required functions under stated
  conditions whenever required—having a long mean time between failures
  \citep{mcconnell2004code}.
\end{defn}

\begin{defn}
  Informally, the reliability of a system is the probability, over a given
  period of time, that the system will correctly deliver services as expected by
  the user \citep{sommerville}. %2011
\end{defn}

\begin{defn}
  Reliability expresses the ability of the software to maintain a specified
  level of fault tolerance, when used under specified condition
  \citep{singh2013different}.
\end{defn}

\begin{mybox}
\subsubsection*{Reliability}
Probability of failure-free operation of a computer program in a specified
environment for a specified time, i.e. the average time interval between two
failures also known as the mean time to failure (MTTF).
\end{mybox}

\subsubsection*{Reasoning}

Definition \ref{reliabilitySelected1} and \ref{reliabilitySelected2} rephrased:.
Reliability is defined such that the measurement metrics are visible - the
specified environment and time.   \wss{Accuracy should be mentioned here, since
it is related to how close the solution is to the correct solution.  Accuracy is
not part of performance.  Maybe make accuracy part of correctness?}  The
different reasons for the proposed definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Robustness (external, product, process)}} %\pmi{owner}

\begin{defn}
	The degree to which a system or component can function correctly in the
	presence of invalid inputs or stressful environmental conditions
	\citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn} \label{RobustnessDefnSelected}
	A program is robust if it behaves ``reasonably'', even in circumstances that
	were not anticipated in the requirements specification - for example, when it
	encounters incorrect input data or some hardware malfunction
	\citep{ghezzi1991fundamentals}. \wss{Use Ghezzi 2003 instead?}
\end{defn}

\begin{defn}
	The quality can be further informally refined as the ability of a software
  to keep an acceptable behaviour, expressed in terms of robustness
  requirements, in spite of exceptional or unforeseen execution conditions
  (such as the unavailability of system resources, communication failures,
  invalid or stressful inputs, etc.) \citep{fernandez2005model}.
\end{defn}

\begin{defn} \label{RobustnessPartialDefn}
	Code possesses the characteristic of robustness to the extent that it can
	continue to perform despite some violation of the assumptions in its 
	specification \citep{boehm2007software}.
\end{defn}

\begin{mybox}
\subsubsection*{Robustness}
Definition~\ref{RobustnessPartialDefn} and
Definition~\ref{RobustnessDefnSelected} rephrased: Software possesses the
characteristic of robustness if it behaves ``reasonably'' in two situations: i)
when it encounters circumstances not anticipated in the requirements
specification; and ii) when the assumptions in its requirements specification
are violated.
\end{mybox}

\subsubsection*{Reasoning}

This definition indicates that robustness is related to the quality of
correctness (both within and outside of it). \pmi{Still may want to refine what
we mean by reasonable}  The different reasons for the proposed definition are as
follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Performance (external, product)} %NOTDONE \pmi{owner}

\begin{defn} \label{PerformanceDefnSelected}
  The degree to which a system or component accomplishes its designated
  functions within given constraints, such as speed, accuracy, or memory
  usage \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn} \label{PerformanceGhezzieEtAl2003}
	Performance ... is an external quality based on user requirements.
  \citep[p.\ 20]{GhezziEtAl2003}.
\end{defn}

\begin{defn} \label{PerformanceDefnSelected2} How well or how rapidly the system
	must perform specific functions. Performance requirements encompass speed
	(database response times, for instance), throughput (transactions per second),
	capacity (concurrent usage loads), and timing (hard real-time demands)
	\citep{wiegers2003softreq}.
\end{defn}

\begin{mybox}
\subsubsection*{Performance}
The extent to which a system or component accomplishes its functional
requirements within the given constraints of speed (database response times,
for instance), throughput (transactions per second), capacity (concurrent usage
loads), and timing (hard real-time demands).
\end{mybox}

\subsubsection*{Reasoning}

The definition is found by combining Definition~\ref{PerformanceDefnSelected}
and Definition~\ref{PerformanceDefnSelected2}.  The two definitions are fairly
similar.  We liked the structure of Definition~\ref{PerformanceDefnSelected} and
the more detailed list of performance aspects in
Definition~\ref{PerformanceDefnSelected2}.  The specific reasons for the
proposed definition are as follows:

\begin{itemize}
  \item We say ``the extent to which'' to be consistent with our other
  definitions.
  \item We changed ``designated functions'' to ``functional requirements'' for
  the goal of being unambiguous.  We already introduced the distinction between
  functional and nonfunctional requirements in the discussion of correctness.
  This also connects the proposed definition to the user requirements, as is
  done by Definition~\ref{PerformanceGhezzieEtAl2003}.
  \item To remove ambiguity, we explicitly list all aspects of performance
  (speed, throughput, capacity and timing), instead of introducing a list that
  is implied to be incomplete via the phrase ``such as''.
  \item We do not include accuracy (from
  Definition~\ref{PerformanceDefnSelected}) because we consider accuracy to be
  related to correctness and reliability.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Usability (external, product, process)}} %\notdone \jc{owner}

\begin{defn}
  ``The effort required to learn, operate, prepare input, and interpret output
  of a program'' \citep{McCallEtAl1977}.
\end{defn}

\begin{defn}
  ``A software is usable - or user friendly - if its human users find it easy
  to use'' \citep{ghezzi1991fundamentals}. \wss{switch to 2003 ref?}
\end{defn}

\begin{defn}
  The extent to which a product can be used by specified users to achieve
  specified goals with effectiveness, efficiency, and satisfaction in a
  specified context of use. \cite{ISO16982:2002} and \cite{ISO9241:11}
\end{defn}

Nielsen and (separately) Schneidermann have defined usability as part of
usefulness and is composed of:
\begin{defn}
\begin{itemize}
\item Learnability: How easy is it for users to accomplish basic tasks the first
  time they encounter the design?
\item Efficiency: Once users have learned the design, how quickly can they
  perform tasks?
\item Memorability: When users return to the design after a period of not using
  it, how easily can they re-establish proficiency?
\item Errors: How many errors do users make, how severe are these errors, and
  how easily can they recover from the errors?
\item Satisfaction: How pleasant is it to use the design?
\end{itemize}
In that context, it makes sense to separate \emph{usefulness} into
\emph{usability} (purely an interface concern) and \emph{utility} (in the
economics sense of the word).
\cite{NielsenNorman} %2012
\end{defn}

\begin{defn}
Desirable outcomes of usability:
\begin{enumerate}
\item It should be easy for the user to become familiar with and competent in
using the user interface during the first contact with the website. For
example, if a travel agent's website is a well-designed one, the user should
be able to move through the sequence of actions to book a ticket quickly.
\item It should be easy for users to achieve their objective through using the
  website. If a user has the goal of booking a flight, a good design will guide
  him/her through the easiest process to purchase that ticket.
\item It should be easy to recall the user interface and how to use it on
  subsequent visits. So, a good design on the travel agent's site means the user
  should learn from the first time and book a second ticket just as easily.
\end{enumerate}
From the Interaction Design Foundation
\url{https://www.interaction-design.org/literature/topics/usability}.
\end{defn}

One core reference, for definitions and metrics, is
\citet{bevan1995measuring}.

\begin{defn}
  The capability of the software to be understood, learned, used and liked by
  the user, when used under specified conditions \cite{ISO9126}.
\end{defn}

\begin{mybox}
\subsubsection*{Usability}
The extent to which a product can be used by specified users to achieve
specified goals with effectiveness, efficiency, and satisfaction in a specified
context of use. \cite{ISO16982:2002} and \cite{ISO9241:11}
\end{mybox}

\subsubsection*{Reasoning}

There has been a lot of thought put behind the ISO definition, from experts. The
standard has been revisited, but the definition has not changed, which means
that it has stood the test of time.  The different reasons for the proposed
definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Verifiability (internal, product, process)}} %\notdone \oo{owner}

\begin{defn}
	 Verification is the process of evaluating a system or component to
   determine whether the products of a given development phase satisfy the
   conditions imposed at the start of that phase
   \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
	Verification involves solving the equations right \citep[p.~23]{Roache1998}.
\end{defn}

\begin{defn}
  A software is verifiable if its properties can be verified easily
  \citep{GhezziEtAl2003}.  \wss{Is this a direct quote?} \oo{yes}
\end{defn}

\begin{defn}
	By verification, we mean all activities that are undertaken to ascertain
  that the software meets its objectives \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
	Verifiability refers to how well software components or the integrated
  product can be evaluated to demonstrate whether the system functions as
  expected \citep{wiegers2003softreq}.
\end{defn}

\begin{defn} \label{Defn_Verifiability1}
  Verifiability ``means that you should be able to write a set of tests that
  can demonstrate that the delivered system meets each specified
  requirement'' \citep{sommerville}. %2011
\end{defn}

\begin{defn}
	The evaluation of whether or not a product, service, or result complies
  with a regulation, requirement, specification, or imposed condition
  \citep{project2017guide} \oo {verification definition}
\end{defn}

\begin{itemize}
	
\item Verification - Are we building the product right?  Are we implementing
the requirements correctly (internal) \item Validation - Are we building the
right product? Are we getting the right requirements (external) \item
According to  \href{https://en.wikipedia.org/wiki/Software_verification_and_validation}
{Capability Maturity Model (CMM)}

\begin{itemize}
\item Software Verification: The process of evaluating software to determine
      whether the products of a given development phase satisfy the conditions
      imposed at the start of that phase. [IEEE-STD-610] \wss{Need a proper
      citation}
\item Software Validation: The process of evaluating software during or at the
      end of the development process to determine whether it satisfies specified
      requirements. [IEEE-STD-610] \wss{Need a proper citation}
\end{itemize}

\end{itemize}
  
``An SRS is verifiable if, and only if, every requirement stated therein is
verifiable. A requirement is verifiable if, and only if, there exists some
finite cost-effective process with which a person or machine can check that the
software product meets the requirement. In general any ambiguous requirement is
not verifiable.'' \citep{IEEE1998}
  
Verifiability is related to testability, which is defined by McCall et al.\
as ``The effort required to test a program to ensure that it performs its
intended function'' \citep{VanVliet2000}. \wss{Need to verify McCall
reference, then delete VanVliet.} \pmi{McCall's definition verbatim: Effort
required to test a program to insure it performs its intended function.}
  
\wss{When I get the Ghezzi text back from Olu, I'll check to see if they have anything to add to this definition.}
  
\begin{defn}
  A software system is verifiable if its properties can be verified easily
  \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{mybox}
\subsubsection*{Verifiability} Definition~\ref{Defn_Verifiability1}
rephrased: Verifiability is the extent to which a set of tests can be
written and executed, to demonstrate that the delivered system meets the
specification.
\end{mybox}

\subsubsection*{Reasoning} 

Definition is concise and measurable.  Verifiability involves solving the
equations right \citep[p.~23]{Roache1998} and the definition states that system
needs to be verifiable based on the specifications.  When applied to process
means ``did we apply the process correctly'', as opposed to validatability, we
refers to ``did we apply the correct process''.   The different reasons for the
proposed definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Validatability (external, product, process)}} %\notdone \oo{owner}

\begin{defn} \label{Defn_Validatability}
  The process of evaluating a system or component during or at the end of the
  development process to determine whether it satisfies specified requirements
  \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
  Validation means solving the right equations \citep[p.~23]{Roache1998}.
\end{defn}

\begin{defn}
  Software validation is achieved through a series of tests that demonstrate
  conformity with requirements \citep{pressman2005software}.
\end{defn}

\begin{defn}
	Validation is concerned with establishing that the product fulfills its
	intended use \citep{van2008software}.
\end{defn}

\begin{defn}
  Software validation is the process of checking that the system conforms to
  its specification and that it meets the real needs of the users of the
  system \citep{sommerville}. %2011
\end{defn}

\begin{defn}
	Software validation, where the software is checked to ensure that it is
  what the customer requires \citep{sommerville}. %2011
\end{defn}

\begin{defn}
  The assurance that a product, service, or result meets the needs of the
  customer and other identified stakeholders \citep{project2017guide}.
\end{defn}

\begin{mybox}
\subsubsection*{Validatability}
Definition \ref{Defn_Validatability} rephrased:  The effort required in
evaluating a system or component during or at the end of the development
process to determine whether it satisfies specified requirements
\end{mybox}

\subsubsection*{Reasoning}

Definition describes that system should be measurable through the
development life cycle, It is concise and can be measured.  The
different reasons for the proposed definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Testability (internal, product)}} %\notdone \oo{owner}

\begin{defn}
	Code possesses the characteristic testability to the extent that it
  facilitates the establishment of verification criteria and supports
  evaluation of its performance \citep{boehm1976quantitative}
\end{defn}

\begin{defn}
	Effort required to test a program to ensure it performs
	its intended function \citep{McCallEtAl1977}.
\end{defn}

\begin{defn} \label{Defn_Testability}
	 The degree to which a system or component facilitates the establishment of
	 test criteria and the performance of tests to determine whether those
	 criteria have been met \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
	The degree to which you can unit-test and system-test a system; the degree
  to which you can verify that the system meets its requirements
  \citep{mcconnell2004code}.
\end{defn}

\begin{mybox}
\subsubsection*{Testability}
Definition \ref{Defn_Testability}: The degree to which a system or component
 facilitates the establishment of test criteria and the performance of tests
 to determine whether those criteria have been met.
\end{mybox}

\subsubsection*{Reasoning}

Definition is concise and measurable.   The different reasons for the proposed
definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Maintainability (internal, product, process)}} %\notdone \pmi{owner}

\begin{defn}
  Effort required to locate and fix an error in an operational program
  \citep{McCallEtAl1977}.

  \wss{It looks like \citet{pressman2005software} was using
  \citet{McCallEtAl1977} for their definition.} \wss{PM - can you please
  look into whether \citet{pressman2005software} cite
  \citet{McCallEtAl1977}?  Do they give a reason for dropping the word
  operational?}  \pmi{Yes, \citet{pressman2005software} does cite the
  relevant section of the textbook with \citet{McCallEtAl1977}. While they
  do not give a reason for specifically dropping the word operational, they
  do indicate that their given definition ``is a very limited definition''.
  Perhaps their intent was breadth.} \wss{Peter, please verify the McCall
  reference definition, and then just cite that.  Olu has found the McCall
  reference, so you shouldn't have to search for it.  We can remove both the
  VanVliet and Pressman reference in preference of the McCall definition.}

  \pmi{I have verified the McCall definition and removed the Pressman and
  van Vliet references above. I will leave these comments until all similar
  definitions in this document have been edited.}
\end{defn}

\begin{defn} \label{MaintainabilityDefnSelected1} 
  The ease with which a software system or component can be modified to correct
  faults, improve performance or other attributes, or adapt to a changed
  environment \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
  We will view maintainability as two separate qualities: repairability and
  evolvability. Software is repairable if it allows the fixing of defects;
  it is evolvable if it allows changes that enable it to satisfy new
  requirements \citep{ghezzi1991fundamentals}. \wss{update to 2003 ref?}
\end{defn}

\begin{defn}
  The capability of the software to be modified.  Modifications may include
  corrections, improvements or adaptation of the software to changes in
  environment, and in requirements and functional specifications.
  \cite{ISO9126} %2001
\end{defn}

\begin{defn}
  A set of attributes that bear on the effort needed to make specified
  modifications (which may include corrections, improvements, or adaptations of
  software to environmental changes and changes in the requirements and
  functional specifications) \citep{pfleeger2006software}.
\end{defn}

\begin{defn} \label{MaintainabilityDefnSelected2}
  Code possesses the characteristic of maintainability to the extent that it
  facilitates updating to satisfy new requirements or to correct deficiencies
  \citep{boehm2007software}.
\end{defn}

\begin{defn}
  ISO/IEC 25010 refers to maintainability as the degree of effectiveness and
  efficiency with which a product or system can be modified by the intended
  maintainers \citep{ISO/IEC25010}. %2011
\end{defn}

\begin{mybox}
\subsubsection*{Maintainability}
Combined altered Definition \ref{MaintainabilityDefnSelected1} and Definition
\ref{MaintainabilityDefnSelected2}: The effort with which a software system or
component can be modified to:
\begin{enumerate}
	\item correct faults
	\item improve performance or other
	attributes
	\item satisfy new requirements
\end{enumerate}
\end{mybox}

\subsubsection*{Reasoning}

This definition offers a comprehensive list of potential reasons for modifying
software, such as correcting faults, improving performance or other attributes,
or satisfying new requirements.

\wss{What are the other attributes?  What is an attribute?  Is it the same
as a quality?  We are calling performance a quality in this document.}

\pmi{The term quality attribute has come up often in the literature -
qualities appear to be a subset of attributes. Quality attributes seem to be
associated with non-functional requirements. The term resource attribute was
encountered in a journal and implied an association with a functional
requirement. The two might differ along those lines of NFR and FR.}

\pmi{I think this is done}

The different reasons for the proposed definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Reusability (internal, product, process)}} %\pmi{owner}

\begin{defn}
  Extent to which a program can be used in other applications - related to
  the packaging and scope of the functions that programs perform
  \citep{McCallEtAl1977}.
\end{defn}

\begin{defn}
  The degree to which a software module or other work product can be used in
  more than one software system \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
  A product is reusable if we can ``use the product - perhaps with minor changes
  - to build another product'' \citep{ghezzi1991fundamentals}.  \wss{Update
  to 2003?}
\end{defn}

\begin{defn} \label{ReusabilityDefnSelected}
  The extent to which a software component can be used with or without
  adaptation in a problem solution other than the one for which it was
  originally developed \citep{kalagiakos2003non}.
\end{defn}

\begin{defn}
  Reusability is the likelihood a segment of source code that can be used
  again to add new functionalities with slight or no modification
  \citep{sandhu2010survey}.
\end{defn}

\begin{mybox}
\subsubsection*{Reusability}
Definition \ref{ReusabilityDefnSelected}: The extent to which a software
component can be used with or without adaptation in a problem solution other
than the one for which it was originally developed.
\end{mybox}

\subsubsection*{Reasoning}

This definition highlights the possible but not necessary adaptation of the
software component(s) being transferred.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Portability (internal, product)}} %\pmi{owner}

\begin{defn} \label{PortabilityDefnSelected}
  Effort required to transfer a program from one hardware configuration
  and/or software system environment to another \citep{McCallEtAl1977}.
\end{defn}

\begin{defn}
  The ease with which a system or component can be transferred from one
  hardware or software environment to another \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
  An application is portable across a class of environments to the degree
  that the effort required to transport and adapt it to a new environment in
  the class is less than the effort of redevelopment
  \citep{mooney1990strategies}.
\end{defn}

\begin{defn}
  Portability refers to the ability to run a system on different hardware
  platforms \citep{ghezzi1991fundamentals}.  \wss{update to 2003?}
\end{defn}

\begin{defn}
  The capability of software to be transferred from one environment to
  another \cite{ISO9126}. %2001
\end{defn}

\begin{defn}
  A set of attributes that bear on the ability of software to be transferred
  from one environment to another (including the organizational, hardware, of
  software environment) \citep{pfleeger2006software}.
\end{defn}

\begin{defn}
  Code possesses the characteristic of portability to the extent that it can
  be operated easily and well on computer configurations other than its
  current one. This implies that special function features, not easily
  available at other facilities, are not used, that standard library
  functions and subroutines are selected for universal applicability, and so
  on \citep{boehm2007software}.
\end{defn}

\begin{mybox}
\subsubsection*{Portability}
Definition \ref{PortabilityDefnSelected} rephrased: Effort required to transfer
a program between system environments (including hardware and software).
\end{mybox}

\subsubsection*{Reasoning}

This is measurable and succinct.   The different reasons for the proposed
definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Understandability (internal, product)}} %\notdone \jc{owner}

\begin{defn}
  The effort ``to uncover the logic of the application''
  \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn}
  The capability of the software product to enable the user to understand
  whether the software is suitable, and how it can be used for particular tasks
  and conditions of use \cite{ISO9126}. %2001
\end{defn}

Understandability is artifact-dependent.  What it means for a user-interface
(graphical or otherwise) to be understandable is wildly different than what
it means for the code, and even the user documentation.

The literature here is thin and scattered.  More work will need to be done
to find something useful.

Interestingly, the business literature seems to have taken more care to
define this.  Here we encounter:

\begin{quote}
  Understandability is the concept that X should be presented so that a reader
  can easily comprehend it.
\end{quote}

At least this brings in the idea that the \emph{reader} is actively involved,
and indirectly that the reader's knowledge may be relevant, as well as the
``clarity of exposition'' of X.

Section 11.2 of \citet{adams2015nonfunctional} does have a full definition.

\begin{mybox}
\subsubsection*{Understandability}
\wss{Still needs to be completed}
\end{mybox}

\subsubsection*{Reasoning}

\wss{Needs to be completed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Interoperability (external, product)}} %\notdone \ad{owner}

\begin{defn}
  Effort required to couple one system with another \citep{McCallEtAl1977}.
  \wss{Ao, if this is from McCall, we should just cite the primary source
  and remove the Van Vliet reference.} \pmi{Yes this is almost exactly from
  McCall, except he did not have the word "The" at the beginning.}
  \ad{Someone with access to the book added it. I found the book in the pub
  folder and fixed it.}
\end{defn}

\begin{defn}
  Interoperability is the ability of two or more systems or components to
  exchange information and to use the information that has been exchanged
  \citep{IEEEComputerDictionary1991}.
\end{defn}

\begin{defn}
  The ability of a system to coexist and cooperate with other systems.
  \citep{ghezzi1991fundamentals}.  \wss{2003 ref?}
\end{defn}

\begin{defn}
  The capability of the software to interact with one or more specified
  systems \cite{ISO9126}. %2001
\end{defn}

\begin{defn}
  The capability to communicate, execute programs, and transfer data among
  various functional units in a manner that requires the user to have little
  or no knowledge of the unique characteristics of those units
  \citep{ISO/IEC/IEEE24765}. %2010
\end{defn}

\begin{defn}
  \label{InteroperabilitySelected} The degree to which two or more systems,
  products or components can exchange information and use the information
  that has been exchanged \citep{ISO/IEC25010}. %2011
\end{defn}

\begin{defn}
  Interoperability is a characteristic of a product or system, whose
  interfaces are completely understood, to work with other products or
  systems, present or future, in either implementation or access, without
  any restrictions \citep{AFUL2019}.
\end{defn}

\begin{defn}
  Interoperability is the ability of different information systems, devices and
  applications (‘systems’) to access, exchange, integrate and cooperatively use
  data in a coordinated manner, within and across organizational, regional and
  national boundaries, to provide timely and seamless portability of information
  and optimize the health of individuals and populations globally. Health data
  exchange architectures, application interfaces and standards enable data to be
  accessed and shared appropriately and securely across the complete spectrum of
  care, within all applicable settings and with relevant stakeholders, including
  by the individual \citep{HIMSS2019}.
	
  Four Levels of Interoperability:
  \begin{itemize}
  \item Foundational (Level 1) – establishes the inter-connectivity requirements
    needed for one system or application to securely communicate data to and
    receive data from another
		
  \item Structural (Level 2) – defines the format, syntax, and organization of
    data exchange including at the data field level for interpretation
		
  \item Semantic (Level 3) – provides for common underlying models and
    codification of the data including the use of data elements with
    standardized definitions from publicly available value sets and coding
    vocabularies, providing shared understanding and meaning to the user
		
  \item Organizational (Level 4) – includes governance, policy, social, legal
    and organizational considerations to facilitate the secure, seamless and
    timely communication and use of data both within and between organizations,
    entities and individuals. These components enable shared consent, trust and
    integrated end-user processes and workflows
  \end{itemize}
\end{defn}

\begin{mybox}
\subsubsection*{Interoperability}
Definition \ref{InteroperabilitySelected}.
\end{mybox}

\subsubsection*{Reasoning}

This definition is concise and also detailed enough to show the concept not only
on system, but also on products and components. It also covered the concept with
more than 2 systems.  The different reasons for the proposed definition are as
follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Productivity (process)}} %\notdone \ad{owner}}

\begin{defn}
  The best definition of the productivity of a process is
	\[\text{Productivity} = \dfrac{\text{Outputs produced by the
              process}}{\text{Inputs consumed by the process}}\]

Thus, we can improve the productivity of the software process by increasing its
outputs, decreasing its inputs, or both. However, this means that we need to
provide meaningful definitions of the inputs and outputs of the software
process. \wss{Where did this definition come from?  Is this all from Boehm?
  This is quite a long quote.  We might actually want to paraphrase.}
\ad{all from Boehm. I feel the best way is deleting everything after the
equation}

\textbf{Defining inputs.} For the software process, providing a meaningful
definition of inputs is a nontrivial but generally workable problem. Inputs to
the software process generally comprise labor, computers, supplies, and other
support facilities and equipment. However, one has to be careful which of
various classes of items are to be counted as inputs. For example:
\begin{itemize}
\item Phases (just software development, or should we include system
engineering, soft-ware requirements analysis, installation, or post development
support?)
\item Activities (to include documentation, project management, facilities
management, conversion, training, database administration?)
\item Personnel (to include secretaries, computer operators, business managers,
contract administrators, line management?)
\item Resources (to include facilities, equipment, communications, current
versus future dollar payments?)
\end{itemize}
An organization can usually reach an agreement on which of the above are
meaningful as inputs in their organizational context. Frequently, one can use
present-value dollars as a uniform scale for various classes of resources.

\textbf{Defining outputs.} The big problem in defining software productivity is
defining outputs. Here we find a defining delivered source instructions (DSI) or
lines of code as the output of the software process is totally inadequate, and
they argue that there are a number of deficiencies in using DSI. However,
	most organizations doing practical productivity measurement still use DSI as
	their primary metric \citep{Boehm1987}. \wss{Is this a direct quote from
		\citet{Boehm1987}?  The sentences seem incomplete?}
\ad{I added some deleted parts, now it is a direct quote. After the ending of
the quote, the following 2 pages discuss the flaws of DCI and a list of
alternatives to DCI, so I ended the quote here.}
\end{defn}

\begin{defn}
  A quality of the software production process, referring to its efficiency
  and performance \citep{ghezzi1991fundamentals}.  \wss{2003 ref?}
\end{defn}

\begin{defn}
	\label{ProductivitySelected2} The number of lines of new code developed per
  person-day (an imperfect measure of productivity but one that could be
  measured consistently) \citep{MacCormack2003}.
\end{defn}

\begin{defn}
	\label{ProductivitySelected1} Productivity is the amount of output (what is
  produced) per unit of input used. In general, productivity is difficult to
  measure because outputs and inputs are typically quite diverse and are
  often themselves difficult to measure. In the context of software,
  productivity measurement is usually based on a simple ratio of product
  size to project effort. Thus,If we can measure the size of the software
  product and the effort required to develop the product, we have:
	\begin{align}
	\text{productivity} = \text{size}/\text{effort}
	\end{align}
  Equation (1) assumes that size is the output of the software production
  process and effort is the input to the process. This can be contrasted
  with the viewpoint of software cost models where we use size as an
  independent variable (i.e., an input) to predict effort which is treated
  as an output. Equation (1) is simple to operationalize if we have a single
  dominant size measure, for example, product size measured in lines of code
  \citep{Kitchenham2004}.
\end{defn}

\begin{mybox}
\subsubsection*{Productivity}
The revision of the combination of Definition \ref{ProductivitySelected1}
and Definition \ref{ProductivitySelected2}: Productivity is the amount of
output per unit of input used, which can be measured by the summation of all
output (such as the number of lines of new code, the number of pages of new
documents and the number of new test cases) produced per person-day.
\wss{Use Long Term Productivity paper}
\end{mybox}

\subsubsection*{Reasoning}

It is concise and measurable. \wss{What is the output?  What is the input? I
think the definition needs to give more information on these.  In particular,
the above definitions focus on code as the output, but documentation, test cases
etc should also be part of the output.  If we are going to measure this, we need
a better idea of what we are measuring for outputs and inputs.} \ad{I added
another def and made it more measurable.}   The different reasons for the
proposed definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Visibility/Transparency (process)}} %\notdone \ad{owner}

\begin{defn}
  \label{VisibilitySelected} A software development process is visible if
  all of its steps and its current status are documented clearly. Another
  term used to characterize this property is transparency
  \citep{ghezzi1991fundamentals}. \wss{change to 2003 ref?}
\end{defn}

\begin{defn}
  Business process visibility, also called process visibility, is the ability to
  accurately and completely view the processes, transactions and other
  activities operating within an enterprise \citep{Rouse2013}.
\end{defn}

\begin{defn}
  Visibility provides transparency into the development process. It is the
  ability to see progress at any point and determine the distance to completion
  of a goal.  Visibility provides status of not only the progress of the
  project, but the product itself \citep{GSA2019}.
\end{defn}

\begin{defn}
  Process transparency refers to the ability to look inside. The “look inside”
  provides an in-depth and clear visibility into the business processes and how
  these operate \citep{PRIME2019}.
\end{defn}

\begin{defn}
The degree to which something is seen by the public
\citep{CambridgeVisibility2019}.
	
The degree to which something is seen or known about
\citep{CambridgeVisibility2019}.
\end{defn}

\begin{mybox}
\subsubsection*{Visibility/Transparency} 
Definition \ref{VisibilitySelected} rephrased: The extent to which all of the
steps of a software development process and the current status of it are
conveyed clearly. \wss{I wonder if rather than ``documented clearly'', we should
be more abstract and talk about how these things can be easily determined.
Documentation is probably how the information will be conveyed, but it doesn't
have to be how it is done.}  \ad{Adjusted}
\end{mybox}

\subsubsection*{Reasoning}

Definition \ref{VisibilitySelected} points out that documentation is the way to
improve visibility. It is rephrased because the original one might refer to
binary status - ``visible'' or ``invisible''.  The different reasons for the
proposed definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Reproducibility (external, product)}} %\notdone \wss{owner}

Reproducibility is a required component of the scientific method
\citep{Davison2012}.  Although QA has, ``a bad name among creative
scientists and engineers'' \citep[p.~352]{Roache1998}, the community need to
recognize that participating in QA management also improves reproducibility.
Reproducibility, like QA, benefits from a consistent and repeatable
computing environment, version control and separating code from
configuration/parameters \citep{Davison2012}.

Reproducibility is defined as:

\begin{defn}
  A result is said to be reproducible if another researcher can take the
  original code and input data, execute it, and re-obtain the same result
  (Peng, Dominici, and Zeger, 2006), as cited in
  \citet{BenureauAndRougier2017}.
\end{defn}

The related concept of replicable is defined as:

\begin{defn}
  Documentation achieves replicability if the description it provides of the
  algorithms is sufficiently precise and complete for an independent researcher
  to re-obtain the results it presents.  \citep{BenureauAndRougier2017}
\end{defn}

\begin{defn}
Closeness of the agreement between the results of measurements of the same measurand carried out under changed conditions of measurement \citep{iso2017iec}.
\end{defn}

\begin{defn}
Obtaining consistent results using the same input data, computational steps,  methods, and code, and conditions of analysis \citep{national2019reproducibility}.
\end{defn}

\begin{defn}
Running the same software on the same input data and obtaining the same results \citep{rougier2017sustainable}.
\end{defn}

It would be worthwhile to look for some additional definitions.

\begin{mybox}
\subsubsection*{Reproducibility} 
\wss{Needs to be completed}
The importance of reproducibility is seen by retractions of influential
papers, like the review of \href{https://www.theguardian
.com/commentisfree/2020/jun/05/lancet-had-to-do-one-of-the-biggest
-retractions-in-modern-history-how-could-this-happen} {hydroxychloroquine
trials}
\end{mybox}

\subsubsection*{Reasoning}

\wss{Reproducibility literature review is given in \citet{FeinbergEtAl2020}.
Includes examples where replicability was found to be lacking.  Has a good
litereature review in Section 2.}

\wss{Needs to be completed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Sustainability (internal, product)}} %\notdone \wss{owner}

One of the original definitions of sustainability (for systems, not software
specific), and still often quoted, is:

\begin{defn}
  \noindent The ability to meet the needs of the present without
  compromising the ability of future generations to meet their own needs
  \citep{Brundtland1987}.
\end{defn}

This is the definition used by \citet{IISD2019}.

To make it more useful, this definition is often split into three dimensions:
social, economic and environmental. \wss{cite UN paper [9] in
  \citet{PenzenstadlerAndHenning2013}} To this list Penzenstadler and Henning
(2013) have added technical sustainability \citep{PenzenstadlerAndHenning2013}.
Where technical sustainability for software is defined as:

\begin{defn}
  \noindent Technical sustainability has the central objective of long-time
  usage of systems and their adequate evolution with changing surrounding
  conditions and respective requirements \citep{PenzenstadlerAndHenning2013}.
\end{defn}

The fourth dimension of technical sustainability is also added by
\citep{WolframEtAl2017}.  Technical sustainability is the focus on the
thesis by \citet{Hygerth2016}.

\begin{defn}
  \noindent Sustainable development is a mindset (principles) and an
  accompanying set of practices that enable a team to achieve and maintain
  an optimal development pace indefinitely \citep{Tate2005}.
\end{defn}

Parnas discusses as software aging \citep{Parnas1994a}.

SCS specific definitions:

\begin{defn}
  The concept of sustainability is based on three pillars: the ecological, the
  economical and the social. This means that for a software to be sustainable,
  we must take all of its effects -- direct and indirect -- on the environment,
  the economy and the society into account. In addition, the entire life cycle
  of a software has to be considered: from planning and conception to
  programming, distribution, installation, usage and disposal \citep{Heine2017}.
\end{defn}

Software Sustainability Institute proposal:

\begin{defn}
Capacity of the software to endure
\end{defn}

\citet{Katz2016} builds on this definition.

\begin{defn}
  \noindent The capacity of the software to endure. In other words,
  sustainability means that the software will continue to be available in
  the future, on new platforms, meeting new needs \citep{Katz2016}.
\end{defn}

\href{https://collegeville.github.io/CW3S19/WorkshopResources/Presentations/4-5-Katz_data-driven-software-sustainability.pdf}
{Katz Presentation}

\href{https://www.software.ac.uk/blog/2019-09-12-making-open-source-research-software-visible-path-better-sustainability}
{Neil's blog}

Definition from Neil Chue Hong:
\begin{defn}
	Sustainable software is software which is:
	-- Easy to evolve and maintain
	-- Fulfils its intent over time
	-- Survives uncertainty
	-- Supports relevant concerns (Political, Economic, Social, Technical,
	Legal, Environmental) \citep{Katz2016}.
\end{defn}

\begin{defn}
Sustainability encompasses cost efficient maintainability and evolvability
\citep{SehestedtEtAl2014}.
\end{defn}

\citet{SehestedtEtAl2014} goes on to say that sustainability can be observed
by evaluating the four criteria of the architectural model: completeness,
consistency, correctness and clarity.

Definitions for sustainability are often built by combining other definitions.
\href{https://collegeville.github.io/CW3S19/WorkshopResources/Presentations/1-4-2019CollegevilleWorkshopWillenbring.pdf}
{Willenbring.pdf}
lists sustainability factors: extensible, interoperable, maintainable,
portable, reusable, scalable and usable.  \wss{Sounds like they are listing
almost all software qualities.  It seems that sustainability is at least in
part achieved by having high quality software.}

From
\href{https://figshare.com/articles/Defining_Sustainability_through_Developers_Eyes_Recommendations_from_an_Interview_Study/1111925/1}
{Rosado de Souza, et al.} there are two categories of software sustainability:

\begin{description}
\item[Intrinsic] Pertaining to characteristics of the software
\item[Extrinsic] Pertaining to the software development environment
\end{description}

\begin{defn}
Sustainable Software is software whose direct and indirect negative impacts on economy, society, human beings, and the environment resulting from development, deployment, and usage of the software is minimal and/or has a positive effect on sustainable development \citep{dick2010model}.
\end{defn}

\begin{defn}
The art of developing sustainable software with a sustainable software engineering process so that negative and positive impacts result in and/or are expected to result from the software product over its whole life cycle are continuously assessed, documented, and used for further optimization of the software product \citep{venters2014software}.
\end{defn}


Find paper that combines nonfunctional qualities into sustainability.

Sounds like definition of maintainability.

Paper critical of a lack of a definition \citep{VentersEtAl2014}.

Sustainability depends on the software artifacts AND the software team AND the
development process.

\begin{mybox}
\subsubsection*{Sustainability} 
\wss{Needs to be completed}
\end{mybox}

\subsubsection*{Reasoning}

\wss{Needs to be completed}.   The different reasons for the proposed definition
are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Direct Qualities} \label{SecDirectQs}

To achieve the  qualities listed in Section~\ref{SecQualities}, the internal
products and process should achieve the qualities listed in this section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Completeness}} %\ontdone \ad{owner}

\begin{defn}
  Those attributes of the software that provide full implementation of the
  functions required. \citep{McCallEtAl1977}. \wss{Ao, if this is from McCall,
  we should just cite the primary source and remove the Van Vliet reference.}
  \pmi{McCall's definition verbatim: Those attributes of the software that
  provide full implementation of the functions required.} \ad{Originally added
  by someone else so I didn't have access to the book. But now it's available
  and I double checked, Peter got it accurately.}
\end{defn}

\begin{defn}
  \label{CompletenessSelected} A specification is complete to the extent
  that all of its parts are present and each part is fully developed. A
  software specification must exhibit several properties to assure its
  completeness \citep{Boehm1984}:
  \begin{itemize}
  \item No TBDs. TBDs are places in the specification where decisions have been
    postponed by writing "To be Determined" or "TBD."
  \item No nonexistent references. These are references in the specification to
    functions, inputs, or outputs (including databases) not defined in the
    specification.
  \item No missing specification items. These are items that should be present
    as part of the standard format of the specification, but are not present.
  \item No missing functions. These are functions that should be part of the
    software product but are not called for in the specification.
  \item No missing products. These are products that should be part of the
    delivered software but are not called for in the specification.
  \end{itemize}
\end{defn}

\begin{defn}
	An SRS is complete if, and only if, it includes the following elements:
\begin{itemize}
\item All significant requirements, whether relating to functionality,
performance, design constraints, attributes, or external interfaces. In
particular any external requirements imposed by a system specification should be
acknowledged and treated.
\item Definition of the responses of the software to all realizable classes of
input data in all realizable classes of situations. Note that it is important to
specify the responses to both valid and invalid input values.
\item Full labels and references to all figures, tables, and diagrams in the SRS
and definition of all terms and units of measure \citep{IEEE1998}.
	\end{itemize}
\end{defn}

\begin{defn}
The quality of being whole or perfect and having nothing missing.
\citep{CambridgeCompleteness2019}.
\end{defn}

\wss{Were there any other definitions of completeness?  You could add the
definition of completeness from \citet[p.\ 5--6]{IEEE1998}.  This definition
is for requirements, but maybe there is something we can generalize from the
definition?  We could also look for definitions outside of software
development.} \ad{added IEEE and dictionary} \ad{\url{https://annals-csis
.org/proceedings/2016/pliks/468.pdf} has a method of measuring completeness
and consistency, but I haven't summarized any def from it yet}

\begin{mybox}
\subsubsection*{Completeness} 
The first sentence of Definition~\ref{CompletenessSelected}: A specification is
complete to the extent that all of its parts are present and each part is fully
developed.
\end{mybox}

\subsubsection*{Reasoning}

It is concise and measurable.  The different reasons for the proposed definition
are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Consistency}} %\notdone \ad{owner}

\begin{defn}
  Those attributes of the software that provide uniform design and
  implementation techniques and notation \citep{McCallEtAl1977}.  \wss{Ao,
    if this is from McCall, we should just cite the primary source and
    remove the Van Vliet reference.} \pmi{McCall's definition verbatim:
  Those attributes of the software that provide uniform design and
  implementation techniques and notation.}\ad{Originally added by someone
  else so I didn't have access to the book. But now it's available and I
  double checked, Peter got it accurately.}
\end{defn}

\begin{defn}
  \label{ConsistencySelected} A specification is consistent to the extent
  that its provisions do not conflict with each other or with governing
  specifications and objectives. Specifications require consistency in
  several ways \citep{Boehm1984}.
  \begin{itemize}
  \item Internal consistency. Items within the specification do not conflict
    with each other.
  \item External consistency. Items in the specification do not conflict with
    external specifications or entities.
  \item Traceability. Items in the specification have clear antecedents in
    earlier specifications or statements of system objectives.
  \end{itemize}
\end{defn}

\begin{defn}
Consistency refers to internal consistency. If an SRS does not agree with some
higher-level document, such as a system requirements specification, then it is
not correct \citep{IEEE1998}.
\end{defn}

\begin{defn}
 An SRS is internally consistent if, and only if, no subset of individual
 requirements described in it conflict. The three types of likely conflicts
 in an SRS are as follows \citep{IEEE1998}:
 \begin{enumerate}[a)]
 \item The specified characteristics of real-world
 objects may conflict. For example,
 \begin{enumerate}[1)]
 \item The format of an output report may be described
 in one requirement as tabular but in another as textual.
 \item One
 requirement may state that all lights shall be green while another may
 state that all lights shall be blue.
 \end{enumerate}
 \item There may be logical or temporal conflict between two specified actions.
 For example,
 \begin{enumerate}[1)]
 \item One requirement may specify that the program will add two inputs and
 another may specify that the program will multiply them.
 \item One requirement may state that “A” must always follow “B,” while another
 may require that “A and B” occur simultaneously.
 \end{enumerate}
 \item Two or more requirements may describe the same real-world object but use
 different terms for that object. For example, a program’s request for a user
 input may be called a “prompt” in one requirement and a “cue” in another. The
 use of standard terminology and definitions promotes consistency.
 \end{enumerate}
\end{defn}

\begin{defn}
  Consistency requires that no two or more requirements in a specification
  contradict each other. It is also often regarded as the case where words
  and terms have the same meaning throughout the requirements specifications
  (consistent use of terminology). These two views of consistency imply that
  mutually exclusive statements and clashes in terminology should be avoided
  \citep{ZOWGHI2003}.
\end{defn}

\begin{defn}
  Consistency: 1. the degree of uniformity, standardization, and freedom
  from contradiction among the documents or parts of a system or component 2
  . software attributes that provide uniform design and implementation
  techniques and notations \citep{ISO/IEC/IEEE24765}.
\end{defn}

\begin{defn}
The state or condition of always happening or behaving in the same way
\citep{CambridgeConsistency2019}.
\end{defn}

\wss{The definition from \citet{IEEE1998} might again be useful.  We could also
  look for definitions outside of software development.  Even a dictionary
  definition could be helpful.}
\ad{added IEEE and dictionary}

\begin{mybox}
\subsubsection*{Consistency} 
The first sentence of Definition~\ref{ConsistencySelected}: A specification is
consistent to the extent that its provisions do not conflict with each other or
with governing specifications and objectives.
\end{mybox}

\subsubsection*{Reasoning}

It is concise and measurable.  The different reasons for the proposed definition
are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Modifiability}} %\notdone \jc{owner}

Here we do seem to have a simple, if somewhat uninformative, definition:

\begin{defn}
  Modifiability is the degree of ease at which changes can be made to a
  system, and the flexibility with which the system adapts to such changes.
\end{defn}

IEEE Standard 610 seems to speak about this. (which is superseded?)

\begin{defn}
\begin{enumerate}
	\item Ease with which a system can be changed without introducing defects.
	\item Degree to which a product or system can be effectively and efficiently modified without introducing defects or degrading existing product quality \citep{iso2017iec}.
\end{enumerate}
\end{defn}

\begin{defn}
Modifiability is about the cost of change and refers to the ease with which a software system can accommodate changes \citep{northrop2004achieving}.
\end{defn}

\begin{mybox}
\subsubsection*{Modifiability} 
The first sentence of Definition~\ref{ConsistencySelected}: A specification is
consistent to the extent that its provisions do not conflict with each other or
with governing specifications and objectives.
\end{mybox}

\subsubsection*{Reasoning}

\wss{Needs to be completed}   The
different reasons for the proposed definition are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Traceability}} %\notdone \jc{owner}

Here the Wikipedia page~\url{https://en.wikipedia.org/wiki/Traceability} is
actually rather informative, especially as it also lists how this concept is
used in other domains.  A generic definition that is still quite useful is

\begin{defn}
  The capability (and implementation) of keeping track of a given set or
  type of information to a given degree, or the ability to chronologically
  interrelate uniquely identifiable entities in a way that is verifiable.
\end{defn}

By specializing the above to software artifacts, ``interrelate'' to ``why is
this here'' (for forward tracing from requirements), this does indeed give
what is meant in SE.

Various standards (DO178C, ISO 26262, and IEC61508) explicitly mention it.

24765-2017 - ISO/IEC/IEEE International Standard - Systems and software
engineering--Vocabulary has a full definition, namely
\begin{enumerate}
\item the degree to which a relationship can be established between two or more
  products of the development process, especially products having a
  predecessor-successor or master-subordinate relationship to one another;
\item the identification and documentation of derivation paths (upward) and
  allocation or flow-down paths (downward) of work products in the work product
  hierarchy;
\item the degree to which each element in a software development product
  establishes its reason for existing; and discernible association among two or
  more logical entities, such as requirements, system elements, verifications,
  or tasks.
\end{enumerate}

\begin{defn}
  The ability to link software components to requirements
  \citep{McCallEtAl1977}. (As summarized in \citet{VanVliet2000}.)
\end{defn} \wss{Once we have verified McCall, we can remove the Van Vliet
reference.}  \pmi{McCall's definition verbatim: Those attributes of the
software that provide a thread from the requirements to the implementation
with respect to the specific development and operational environment.}

\begin{defn}
This is the property of a system description technique which allows changes in one of the three system descriptions -- requirements, specification, implementation -- to be traced to the corresponding portions of the other descriptions. The correspondence should be maintained throughout the lifetime of the system \citep{greenspan1978structuring}.
\end{defn}

\begin{defn}
The ability to relate requirements specifications with other artefacts created
in the development life-cycle of a software system \citep{spanoudakis2002plausible}.
\end{defn}

\begin{defn}
Symbol identification that permits symbols to be traced throughout a software system. Also, continuity between program versions \citep{graf1999modern}.
\end{defn}

\begin{mybox}
\subsubsection*{Traceability} 
\wss{Needs to be completed.}
\end{mybox}

\subsubsection*{Reasoning}

\wss{Needs to be completed}  The different reasons for the proposed definition
are as follows:

\begin{itemize}
  \item reason 1
  \item reason 2
  \item ...
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Unambiguity}} %\notdone \wss{owner}

\begin{defn}
 \label{IEEEunambiguity}A Software Requirements Specification (SRS) is unambiguous if, and only if,
 every requirement stated therein has only one interpretation \citep{IEEE1998}.
\end{defn}

\begin{defn}
	\label{UnambiguitySelected} (1) Not having two or more possible meanings. (2) Not susceptible to different interpretations. (3) Not obscure, not vague. (4) Clear, definite, certain. \citep{FDA2014}.
\end{defn}

\begin{mybox}
\subsubsection*{Unambiguity} 
Unambiguity is the quality of having one clear interpretation, and not having any other possible interpretations.
\end{mybox}

\subsubsection*{Reasoning}

The recommended definition comes from rephrasing Definition \ref{UnambiguitySelected} while keeping in mind its similarities with Definition \ref{IEEEunambiguity}. The rationale for the proposed definition follows:

\begin{itemize}
  \item Definition \ref{IEEEunambiguity} mentions the ``Software Requirements Specification'' document and, the specifically related term, ``requirement''. We feel that for the sake of abstraction we should not have the definition focus solely on this specific document and its related term, so we do not include these in the chosen definition.
  \item The term ``interpretation'' is found in both Definition \ref{IEEEunambiguity} and Definition \ref{UnambiguitySelected} and is kept in the chosen definition.
  \item The first two parts of Definition \ref{UnambiguitySelected} can be succinctly restated as ``having one interpretation''.
  \item The fourth part of Definition \ref{UnambiguitySelected} can be added to the above phrase, resulting in the new phrase ``having one clear interpretation''. This removes the possibility of one vague interpretation, also addressing the third part of Definition \ref{UnambiguitySelected}.
  \item The new phrase ``having one clear interpretation'' is still ambiguous as there could be one clear interpretation, and one or more vague interpretations. This is addressed by adding a phrase stating that there are no other possible interpretations besides the one clear interpretation.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{\notdone{Abstract}} %\notdone \wss{owner}

\begin{defn}
  Documented requirements are said to be abstract if they state what the
  software must do and the properties it must possess, but do not speak about
  how these are to be achieved \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
  ``An abstraction for a software artifact is a succinct description that
  suppresses the details that are unimportant to a software developer and
  emphasizes the information that is important.'' \citep{Krueger1992}
\end{defn}

\begin{defn}
  ``Abstraction means that we concentrate on the essential features and ignore,
  abstract from, details that are not relevant at the level we are currently
  working.''  \citep[p.\ 296]{VanVliet2000}
\end{defn}

\begin{defn}
  ``Abstraction in mathematics is the process of extracting the underlying
  essence of a mathematical concept, removing any dependence on real world
  objects with which it might originally have been connected, and generalizing
  it so that it has wider applications or matching among other abstract
  descriptions of equivalent phenomena.''
  \href{https://en.wikipedia.org/wiki/Abstraction_(mathematics)} {Wikipedia
    Definition}
\end{defn}

\begin{defn}
Abstraction refers to the process of removing irrelevant details in order to focus on the essential parts of the system \citep{filipovikj2017pattern}.
\end{defn}	

\begin{defn}
Abstraction is a special case of separation of concerns wherein we separate the concerns of the important aspects from the concern of the less important details \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
An abstraction is a simplification of some complex element of a system used to communicate meaning in a single phrase \citep{roger2015software}.
\end{defn}

Abstraction is related to reusability (and other qualities).

\wss{When I get the Ghezzi text back from Olu, I'll check to see if they have
  anything to add to this definition.}

\begin{mybox}
\subsubsection*{Abstract} 
\wss{Needs to be completed}
\end{mybox}

\subsubsection*{Reasoning}

\wss{Needs to be completed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\bibliographystyle {plainnat}
\bibliography {../../CommonFiles/ResearchProposal}

\end{document}


% possibly useful definitions

\subsection{Additional Definitions}

Some standards give additional definitions for terms that are used a lot.
These are reproduced here, to aid in the interpretation of the definitions
below (and their refinement).

\begin{defn} 
\textsf{Effectiveness}:
The accuracy and completeness with which users achieve specified
goals. \cite{ISO9241:11}
\end{defn}

\begin{defn} 
\textsf{Efficiency}: 
The resources expended in relation to the accuracy and
completeness with which users achieve goals. \cite{ISO9241:11}
\end{defn}

\begin{defn}
\textsf{Satisfaction}: 
Freedom from discomfort, and positive attitude to the use of the product.
\cite{ISO9241:11}
\end{defn}

\begin{defn}
\textsf{Context of use}:
characteristics of the users, tasks and the organizational and physical
environments. \cite{ISO9241:11}
\end{defn}

\begin{defn}
\textsf{Goal}: intended outcome. \cite{ISO9241:11}
\end{defn}

\begin{defn}
\textsf{Task}: activities required to achieve a goal. \cite{ISO9241:11}
\end{defn}