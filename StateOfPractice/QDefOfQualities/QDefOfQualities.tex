\documentclass[letterpaper,cleveref]{lipics-v2019}

\usepackage{natbib}
\usepackage{booktabs}
\usepackage{amsmath,amsthm}

\usepackage{hyperref}
\hypersetup{
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with
%linkbordercolor)
citecolor=blue,       % color of links to bibliography
filecolor=magenta,   % color of file links
urlcolor=cyan           % color of external links
}

%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}} %Spencer Smith
\newcommand{\jc}[1]{\authornote{red}{JC}{#1}} %Jacques Carette
\newcommand{\oo}[1]{\authornote{magenta}{OO}{#1}} %Olu Owojaiye
\newcommand{\pmi}[1]{\authornote{green}{PM}{#1}} %Peter Michalski
\newcommand{\ad}[1]{\authornote{cyan}{AD}{#1}} %Ao Dong

\newcommand{\notdone}[1]{\textcolor{red}{#1}}
\newcommand{\done}[1]{\textcolor{black}{#1}}

%\oddsidemargin 0mm
%\evensidemargin 0mm
%\textwidth 160mm
%\textheight 200mm

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\title{Quality Definitions of Qualities} 
\author{Spencer Smith}{McMaster University, Canada}{smiths@mcmaster.ca}{}{}
\author{Jacques Carette}{McMaster University, Canada}{carette@mcmaster.ca}{}{}
\author{Olu Owojaiye}{McMaster University, Canada}{owojaiyo@mcmaster.ca}{}{}
\author{Peter Michalski}{McMaster University, Canada}{michap@mcmaster.ca}{}{}
\author{Ao Dong}{McMaster University, Canada}{}{}{}

\authorrunning{Smith et al.}  \Copyright{Spencer Smith and Jacques Carette and
Olu Owojaiye and Peter Michalski and Ao Dong}

\date{\today}

\hideLIPIcs
\nolinenumbers

\begin{document}
\maketitle

\begin{abstract}
	...
\end{abstract}

\tableofcontents

\section{Introduction} \label{SecIntroduction}

Purpose and scope of the document.  \wss{Needs to be filled in.  Should
	reference the overall research proposal, and the ``state of the practice''
	exercise in particular.}

The presentation is divided into two main sections: i) qualities that apply to
software products, software artifacts and software development processes, and
ii) qualities that are considered important for good specifications.  The
specification could be a specification of requirements, design or a test plan.

The pattern in the presentation for each of the qualities is the same.  First we
summarize all of the definitions that we could find in the literature.  To keep
the clutter of quotation marks down, we have adopted the convention that each
definition is given verbatim from the cited source, but without showing
quotation marks.  After the summary of the existing definitions, we propose the
definition that we would like to work with going forward.  This definition can
either be our preference from the existing definitions, or a new definition,
which is often found by combining existing definitions.  Following the proposed
definition is an explanation for the reasoning that led to this choice.

\section{Qualities of Software Products, Artifacts and
	Processes} \label{SecQualities}

To assess the current state of software development, and to understand how
future changes impact software development, we need a clear definition of what
we mean by quality.  The concept of quality is decomposed into a set of separate
components that together make up ``quality''. Unfortunately, these are
called \emph{qualities}. These are associated to the software product,
the software artifacts (documentation, test cases, etc) and to the software
development process itself, and combinations thereof.

Our analysis is centred around a set of software qualities.  Quality is not
considered as a single measure, but a collection of different qualities, often
called ``ilities.''  These qualities highlight the desirable nonfunctional
properties for software artifacts, which include both documentation and
code. Some qualities, such as visibility and productivity, apply to the process
used for developing the software. The following list of qualities is based on
\cite{GhezziEtAl2003}. To the list from \cite{GhezziEtAl2003}, we have added
three qualities important for SC: installability, reproducibility and
sustainability.

\subsection{\notdone{Installability} \oo{owner}}

\begin{defn}
	A measure of the ease of installation \citep{smith2015comparing}.\wss{Where
	does this definition come from? Please add a citation.  Is it from
	\citet{McCallEtAl1977}? I thought so originally, but after looking into it, I
	don't think so anymore.}
	\oo{@smith you added the definition in here but I guess it's from here}
\end{defn}

\begin{defn}
	The capability of a software product to be installed in a specified
	environment \citep{iso2001iec}. (As summarized in \citep{berander2005software}.)  \wss{remove the quotation marks -
	we are assuming all definitions are directly quoted from the source. Please
	remove quotes for all of the definitions that you ``own.''}
    \oo{Done} 
\end{defn}

\begin{defn} \label{Installability_Selected2}
	The degree of effectiveness and efficiency with which a product or system can
	be successfully installed and/or uninstalled in a specified environment
	\citep{ISO/IEC25010}.
\end{defn}

\begin{defn} \label{Installability_Selected1}
	Installability refers to the cost or effort required for the installation, given an installation is possible to begin with
	\citep{lenhard2013measuring}.
\end{defn}

\noindent \textbf{Proposed Definition}

Combined definitions \ref{Installability_Selected1} and
\ref{Installability_Selected2} rephrased.
Installability refers to the cost or effort required for the installation,
uninstallation or reinstallation of a software or product in a specified
enviroment.  \wss{This definition does not allow for
	measuring the machine time.}

\noindent \textbf{Reasoning}

\wss{The rationale is missing.  Please add.} \oo{Done}
The definition captures the cost or effort - human or machine, and considers not just the initial installation but uninstallation and re-installation which are all related to installation activities.
\oo{Done installability}
\subsection{\notdone{Correctness} \oo{owner}}

\begin{defn}  
	A program is functionally correct if it behaves according to its stated
   functional specifications \citep{GhezziEtAl2003}.  \wss{This is not how
		\citet{GhezziEtAl2003} defines correctness.  They only require satisfaction
		of the functional requirements.} \oo{Updated}
	
\end{defn}

\begin{defn}
	According to \citet{wilson2009quality}, the degree to which a system is free
	from defects in its specification, design, and implementation, is its
	correctness.
\end{defn}

\begin{defn}
	The ability of software products to perform their exact tasks, as defined by
	their specification \citep{meyer1988object}.
\end{defn}

\begin{defn} 
	The extent to which a program satisfies its specifications and fulfills the
	user's mission objectives \citep{McCallEtAl1977}. (As summarized in
	\citet{VanVliet2000}.)
\end{defn}

\begin{defn} \label{Correctness_Selected}
 The degree to which a system or component is free from faults in its specification, design and implementation \citep{IEEEComputerDictionary1991}.
\end{defn}

\begin{defn}
	Correctness from software engineering perspective can be defined as the adherence to the specifications that determine how users can interact with the software and how the software should behave when it is used correctly \citep{Tutorialspoint}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition~\ref{Correctness_Selected}: The degree to which a system or component is free from faults in its specification, design and implementation.

\noindent \textbf{Reasoning}

To determine whether a program is correct, we must be able to refer to both its its specification, design and implementation to understand the intended purpose and based on defined metrics, determine the extent to which this is met. Most definitions of correctness refers only to functional specifications but this definition is broad and is able to capture both functional and non-functional specification without explicitly specifying it.\oo{We could modify te definition to explicitly state functional and non-functional if we decide.}
There is no direct tool or method for measuring correctness. One way of building
confidence in correctness is by reviewing to ensure that each requirement stated
is one that the stakeholders and experts desire.  By maintaining traceability,
consistency and unambiguity, we can reduce the occurrence of errors and make the
goal of reviewing for correctness easier.

The quality of a software's operation is dependent on the degree of correctness
\citep{berander2005software}. Correctness and reliability are said to have
dependencies, such that if a system exhibits a high degree of correctness then
it tends to be reliable \citep{GhezziEtAl2003}. \oo{Done Correctness}

\subsection{\notdone{Verifiability/Testability} \oo{owner}}

\begin{defn}
	A software is verifiable if its properties can be verified easily
	\citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
	Attributes of software that relate to the effort needed for validating the modified software \citep{iso2001iec}.
\end{defn}

\begin{defn}
	Effort required to test a program to ensure that it performs its intended
	function \citep{McCallEtAl1977}. (As summarized in \citet{pressman2005software})
\end{defn}

\begin{defn}
    Testability is the degree to which a requirement is stated in terms that permits establishment of test criteria and performance of tests to determine whether those criteria have been met \citep{IEEEStdGlossarySET1990}
\end{defn}
\begin{defn}
	Code possesses the characteristic testability to the extent that it facilitates the establishment of verification criteria and supports evaluation of its performance \citep{boehm1976quantitative}.
\end{defn}

\begin{defn} \label{Defn_Verifiability1}
	Testability is the degree to which a system or component facilitates the establishment of test criteria and the performance of tests to determine whether those criteria have been met \citep{ISO/IEC/IEEE24765}.
\end{defn}

\begin{defn} \label{Defn_Verifiability2}
	Testability is the effort required to test a software \citep{ISO/IEC/IEEE24765}.
\end{defn}

\noindent \textbf{Proposed Definition}

Combined definitions~\ref{Defn_Verifiability1} and~\ref{Defn_Verifiability2} rephrased: Testability or verifiability is the degree to which a system or component facilitates the establishment of test criteria and the performance of tests to determine whether those criteria have been met and the effort required to test.

\noindent \textbf{Reasoning}
Definition is concise and measurable.
Verifiability involves solving the equations right
\citep[p.~23]{Roache1998};
it benefits from rational documentation that systematically shows, with explicit
traceability, how the governing equations are transformed into code.
\oo{Verifiability is sometimes referred to as testability, so I culled some
	testability definitions and added here}  \wss{culled means removed - is that your
	intention?} \oo{culled could also mean  'to choose', so I meant, I choose from some definitions of testability and added to the list}

\wss{In case we need it, here is a definition of testability.}

\begin{defn}
	The effort required to test a program to ensure that it performs its
	intended function \citep{McCallEtAl1977}. (As summarized in
	\citet{VanVliet2000}.) \oo{similar to \citep{pressman2005software}, this}
\end{defn}


\subsection{\notdone{Validatability} \oo{owner}}

\begin{defn}
	Validatability of a software is the degree of ease in validating (checking)
	that software meets user needs. \wss{Need a citation} \oo{To be removed, I don't have any citation, definition was modified from the definition of verifiability}
\end{defn}

\begin{defn}
	Validatability means solving the right equations
	\citep[p.~23]{Roache1998}.
	\oo{Validation?}
\end{defn}

\begin{defn} \label{Validatability_Selected}
   Validation is the process of evaluating software during or at the end of the development
   process to determine whether it satisfies specified business requirements \citep{softwaretestingfundamentals}.

\end{defn}

\begin{defn}
	Validation refers to a different set
	of tasks that ensure that the software that has been built is traceable to customer requirements.
\end{defn}
\noindent \textbf{Proposed Definition}

\begin{defn}
	Requirements validation examines the specification to ensure that all
	software requirements have been stated unambiguously; that inconsistencies, omissions, and errors have been detected and corrected; and that the work products conform to the standards established for the process, the project, and the product \citep{pressman2005software}.
\end{defn}

\begin{defn}
    Software validation checks that the software product satisfies or fits the intended use (high-level checking), i.e., the software meets the user requirements, not as specification artifacts or as needs of those who will operate the software only; but, as the needs of all the stakeholders (such as users, operators, administrators, managers, investors, etc.) \citep{WikipediaVnV}
\end{defn}
\noindent \textbf{Proposed Definition}: Definition~\ref{} \oo{need to discuss this quality, we might just define validatability from validation definitions above? Resources are limited for 'validatability'}.

\noindent \textbf{Reasoning}

Validatability is improved by a rational process via clear documentation of the
theory and assumptions, along with an explicit statement of the systematic steps
required for experimental validation. It is entirely possible that a product passes when verified but fails when validated. This can happen when, say, a product is built as per the specifications but the specifications themselves fail to address the user’s needs

\subsection{\notdone{Reliability} \oo{owner}}

\begin{defn}
	The probability that the software will operate as expected over a specified
	time interval \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
	A set of attributes that relate to the capability of software to maintain its
	level of performance under stated conditions for a stated period of time \citep{iso2001iec}. (As summarized in \citet{berander2005software}.)
\end{defn}

\begin{defn} \label{reliabilitySelected1}
	Probability of failure-free operation of a computer program in a specified environment for a specified time \citep{musa1987software}. (As stated in \citet{pressman2005software}.)
\end{defn}

\begin{defn}
	Code possesses the characteristic reliability to the extent that it can be
	expected to perform its intended functions satisfactorily
	\citep{boehm1976quantitative}.
\end{defn}

\begin{defn} \label{reliabilitySelected2}
   Reliability expresses the ability of the software to maintain a specified
   level of fault tolerance, when used under specified condition \citep{singh2013different}.
\end{defn}
\begin{defn}
	The extent to which a program can be expected to perform its intended
	function with required precision \citep{McCallEtAl1977}. (As summarized in
    \citet{VanVliet2000}.)
\end{defn}

\begin{defn}
	Informally, the reliability of a system is the probability, over a given
	period of time, that the system will correctly deliver services as expected by
	the user \citep{sommerville}
\end{defn}
	
\begin{defn}
	The ability of a system or component to to perform its required function under stated conditions for a specified period of time \citep{IEEEComputerDictionary1991}
\end{defn}


\noindent \textbf{Proposed Definition}
Definition \ref{reliabilitySelected1} and \ref{reliabilitySelected2} rephrased : 	Probability of failure-free operation of a computer program in a specified environment for a specified time at a specified level of fault tolerance.

\wss{Needs to be completed.}\oo{Done}

\noindent \textbf{Reasoning}
Reliability is defined in a way that the measurement metrics are visible - the specified enviroment, the specified time and the specified level of fault tolerance. Reliability is a critical quality for scientific software, since the results of
computations are meaningless, if they are not dependable.  Reliability is
closely tied to verifiability, since the key quality to verify is reliability,
while the act of verification itself improves reliability.

Reliability models can be used to predict reliability of a software product. For
example measuring Mean Time to Fail (MTTF) can be a good measure of reliability
\citep{berander2005software}.

\subsection{{Robustness} \pmi{owner}}
\begin{defn}
	The degree to which a system or component can function correctly in the
	presence of invalid inputs or stressful environmental conditions
	\citep{IEEEStdGlossarySET1990}.
\end{defn}
\begin{defn}
	The quality can be further informally refined as the ability of a software to
	keep an acceptable behaviour, expressed in terms of robustness requirements,
	in
	spite of exceptional or unforeseen execution conditions (such as the
	unavailability of system resources, communication failures, invalid or
	stressful inputs, etc.) \citep{fernandez2005model}.
\end{defn}
\begin{defn} \label{RobustnessPartialDefn}
	Code possesses the characteristic of robustness to the extent that it can
	continue to perform despite some violation of the assumptions in its
	specification \citep{boehm2007software}.
\end{defn}
\begin{defn} \label{RobustnessDefnSelected}
	A program is robust if it behaves ``reasonably'', even in circumstances that
	were not anticipated in the requirements specification - for example, when it
	encounters incorrect input data or some hardware malfunction
	\citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{RobustnessPartialDefn} and Definition
\ref{RobustnessDefnSelected} rephrased: Software possesses the
characteristic of robustness if it behaves ``reasonably'' in two situations: i)
when it encounters circumstances not anticipated in the requirements
specification; and ii) when the assumptions in its requirements specification
are violated.

\noindent \textbf{Reasoning}

This definition indicates that robustness is related to the quality of
correctness (both within and outside of it). 

\pmi{Still may want to refine what we mean by reasonable}

\subsection{\notdone{Performance} \pmi{owner}}

\begin{defn} \label{PerformanceDefnSelected}
	The degree to which a system or component accomplishes its designated functions
	within given constraints, such as speed, accuracy, or memory usage
	\citep{IEEEStdGlossarySET1990}.
\end{defn}
\begin{defn} \label{PerformanceDefnSelected2}
	How well or how rapidly the system must perform specific functions. Performance
	requirements encompass speed (database response times, for instance), throughput
	( transactions per second), capacity (con-current usage loads), and timing (hard
	real-time demands) \citep{wiegers2003softreq}.
\end{defn}
\begin{defn}
	In software engineering we often equate performance with efficiency. A software
	system is efficient if it uses computing resources economically
	\citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

Combined definition \ref{PerformanceDefnSelected} and
\ref{PerformanceDefnSelected2}: The degree to which a system or component
accomplishes its designated functions within given constraints, such as speed
(database response times, for instance), throughput ( transactions per second),
capacity (con-current usage loads), and timing (hard real-time
demands). \wss{What is the difference between speed and timing?}

\noindent \textbf{Reasoning}

This definition offers a comprehensive list of constraints that are commonly
associated with software performance, such as speed, throughput, capacity, and
timing.

\pmi{I will check if Wiegers discusses the difference between speed and timing.}
\pmi{Wiegers did not discuss this difference.}
\pmi{Speed - change over time; timing - related to specification: when something
	should happen in relation to something else - state transitions}

\subsection{\notdone{Usability} \jc{owner}} 

\begin{defn}
	The extent to which a product can be used by specified users to achieve
	specified goals with effectiveness, efficiency, and satisfaction in a specified
	context of use.
\end{defn}
ISO defines usability as

Nielsen and (separately) Schneidermann have defined usability as part of
usefulness and
is composed of:
\begin{itemize}
	\item Learnability: How easy is it for users to accomplish basic tasks the
	first time they encounter the design?
	\item Efficiency: Once users have learned the design, how quickly can they
	perform tasks?
	\item Memorability: When users return to the design after a period of not using
	it, how easily can they re-establish proficiency?
	\item Errors: How many errors do users make, how severe are these errors, and
	how easily can they recover from the errors?
	\item Satisfaction: How pleasant is it to use the design?
\end{itemize}
In that context, it makes sense to separate \emph{usefulness} into
\emph{usability} (purely an interface concern) and \emph{utility} (in the
economics
sense of the word).

There are two ISO standards covering this, namely ISO/TR 16982:202 and ISO 9241.


The Interaction Design
Foundation~\url{https://www.interaction-design.org/literature/topics/usability}
further lists the following desirable outcomes:

\begin{enumerate}
	\item It should be easy for the user to become familiar with and competent in
	using
	the user interface during the first contact with the website. For example, if a
	travel agent’s website is a well-designed one, the user should be able to move
	through the sequence of actions to book a ticket quickly.
	\item It should be easy for users to achieve their objective through using the
	website. If a user has the goal of booking a flight, a good design will guide
	him/her through the easiest process to purchase that ticket.
	\item It should be easy to recall the user interface and how to use it on
	subsequent visits. So, a good design on the travel agent’s site means the user
	should learn from the first time and book a second ticket just as easily.
\end{enumerate}

One core reference, for definitions and metrics, is
\citet{bevan1995measuring}.

\begin{defn}
	``The effort required to learn, operate, prepare input, and interpret output
	of a program'' \citep{McCallEtAl1977}. (As summarized in
	\citet{VanVliet2000}.)
\end{defn}

\begin{defn}
	``A software is usable - or user fridendly - if its human users find it easy to
	use'' \citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

\wss{Still needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Maintainability} \pmi{owner}}

\begin{defn} \label{MaintainabilityDefnSelected1}
	The ease with which a software system or component can be modified to correct
	faults, improve performance or other attributes, or adapt to a changed
	environment \citep{IEEEStdGlossarySET1990}. 
\end{defn}
\begin{defn}
	ISO/IEC 25010 refers to maintainability as the degree of effectiveness and
	efficiency with which a product or system can be modified by the intended
	maintainers \citep{ISO/IEC25010}.
\end{defn}
\begin{defn}
	Effort required to locate and fix an error in a program
	\citep{pressman2005software}.
\end{defn}
\begin{defn}
	A set of attributes that bear on the effort needed to make specified
	modifications (which may include corrections, improvements, or adaptations of
	software to environmental changes and changes in the requirements and functional
	specifications) \citep{pfleeger2006software}.
\end{defn}
\begin{defn}
	We will view maintainability as two separate qualities: repairability and
	evolvability. Software is repairable if it allows the fixing of defects; it is
	evolvable if it allows changes that enable it to satisfy new requirements
	\citep{ghezzi1991fundamentals}.
\end{defn}
\begin{defn} \label{MaintainabilityDefnSelected2}
	Code possesses the characteristic of maintainability to the extent that it
	facilitates updating to satisfy new requirements or to correct deficiencies
	\citep{boehm2007software}.
\end{defn}

\begin{defn}
	The effort required to locate and fix an error in an operational program
	\citep{McCallEtAl1977}. (As summarized in \citet{VanVliet2000}.) \wss{It looks
		like \citet{pressman2005software} was using \citet{McCallEtAl1977} for their
		definition.} \wss{PM - can you please look into whether
		\citet{pressman2005software} cite \citet{McCallEtAl1977}?  Do they give a
		reason for dropping the word operational?}
	\pmi{Yes, \citet{pressman2005software} does cite the relevant section of the
		textbook with \citet{McCallEtAl1977}. While they do not give a reason for
		specifically dropping the word operational, they do indicate that their given
		definition ``is a very limited definition''. Perhaps their intent was breadth.}
\end{defn}

\noindent \textbf{Proposed Definition}

Combined Definition \ref{MaintainabilityDefnSelected1} and Definition
\ref{MaintainabilityDefnSelected2}: The ease with which a software system or
component can be modified to correct faults, improve performance or other
attributes, or satisfy new requirements.

\noindent \textbf{Reasoning}

This definition offers a comprehensive list of potential reasons for modifying
software, such as correcting faults, improving performance or other attributes,
or satisfying new requirements.

\wss{What are the other attributes?  What is an attribute?  Is it the
	same as a quality?  We are calling performance a quality in this document.}
\pmi{The term quality attribute has come up often in the literature - qualities
	appear to be a subset of attributes. Quality attributes seem to be associated
	with non-functional requirements. The term resource attribute was encountered in
	a journal and implied an association with a functional requirement. The two
	might differ along those lines of NFR and FR.}

\pmi{I think this is done}

\subsection{{Reusability} \pmi{owner}}

\begin{defn} 
	The degree to which a software module or other work product can be used in more
	than one software system \citep{IEEEStdGlossarySET1990}. 
\end{defn}
\begin{defn}
	Extent to which a program [or parts of a program] can be reused in other
	applications - related to the packaging and scope of the functions that the
	program performs \citep{pressman2005software}.
\end{defn}
\begin{defn} \label{ReusabilityDefnSelected}
	The extent to which a software component can be used with or without adaptation
	in a problem solution other than the one for which it was originally developed
	\citep{kalagiakos2003non}.
\end{defn}
\begin{defn}
	Reusability is the likelihood a segment of source code that can be used again to
	add new functionalities with slight or no modification \citep{sandhu2010survey}.
\end{defn}

\begin{defn}
	The extent to which a program (or parts thereof) can be reused in other
	applications \citep{McCallEtAl1977}. (As summarized in
	\citet{VanVliet2000}.)
\end{defn}

\begin{defn}
	A product is reusable if we can ``use the product - perhaps with minor changes -
	to build another product'' \citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{ReusabilityDefnSelected}: The extent to which a software
component can be used with or without adaptation in a problem solution other
than the one for which it was originally developed.

\noindent \textbf{Reasoning}

This definition highlights the possible but not necessary adaptation of the
software component(s) being transferred.

\subsection{\notdone{Portability} \pmi{owner}}
\begin{defn}
	The ease with which a system or component can be transferred from one hardware
	or software environment to another \citep{IEEEStdGlossarySET1990}.
\end{defn}
\begin{defn}
	An application is portable across a class of environments to the degree that the
	effort required to transport and adapt it to a new environment in the class is
	less than the effort of redevelopment \citep{mooney1990strategies}.
\end{defn}
\begin{defn} \label{PortabilityDefnSelected}
	Effort required to transfer the program from one hardware and/or software system
	environment to another \citep{pressman2005software}.
\end{defn}
\begin{defn}
	A set of attributes that bear on the ability of software to be transferred from
	one environment to another (including the organizational, hardware, of software
	environment) \citep{pfleeger2006software}.
\end{defn}
\begin{defn}
	Code possesses the characteristic of portability to the extent that it can be
	operated easily and well on computer configurations other than its current
	one. This implies that special function features, not easily available at other
	facilities, are not used, that standard library functions and subroutines are
	selected for universal applicability, and so on \citep{boehm2007software}.
\end{defn}
\begin{defn}
	Portability refers to the ability to run a system on different hardware
	platforms \citep{ghezzi1991fundamentals}.
\end{defn}
\begin{defn}
	``The effort required to transfer a program from one hardware and/or software
	environment to another'' \citep{McCallEtAl1977}. (As summarized in
	\citet{VanVliet2000}.)
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{PortabilityDefnSelected} rephrased: Effort required to transfer
a program between system environments (including hardware and software).

\noindent \textbf{Reasoning}

This is measurable and succinct. 

\pmi{I think this is done.}

\subsection{\notdone{Understandability} \jc{owner}}

Understandability is artifact-dependent. What it means for a user-interface
(graphical
or otherwise) to be understandable is wildly different than what it means for
the code,
and even the user documentation.

The literature here is thin and scattered.  More work will need to be done to
find
something useful.

Interestingly, the business literature seems to have taken more care to define
this.
Here we encounter
\begin{quote}
	Understandability is the concept that X should be presented
	so that a reader can easily comprehend it.
\end{quote}
At least this brings in the idea that the \emph{reader} is actively involved,
and
indirectly that the reader's knowledge may be relevant, as well as the
``clarity of exposition'' of X.

Section 11.2 of \citet{adams2015nonfunctional} does have a full definition.

\begin{defn}
	The effort ``to uncover the logic of the application''
	\citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

\wss{Still needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\done{Interoperability} \ad{owner}}

\begin{defn}
	``The effort required to couple one system with another''
	\citep{McCallEtAl1977}. (As summarized in \citet{VanVliet2000}.)
\end{defn}

\begin{defn}
	Interoperability is the ability of two or more systems or components to exchange
	information and to use the information that has been exchanged
	\citep{IEEEComputerDictionary1991}.
\end{defn}
\begin{defn}
	\label{InteroperabilitySelected}
	The degree to which two or more systems, products or components can exchange
	information and use the information that has been exchanged
	\citep{ISO/IEC25010}.
\end{defn}
\begin{defn}
	The ability of a system to coexist and cooperate with other systems.
	\citep{ghezzi1991fundamentals}.
\end{defn}
\begin{defn}
	The capability to communicate, execute programs, and transfer data among various
	functional units in a manner that requires the user to have little or no
	knowledge of the unique characteristics of those units
	\citep{ISO/IEC/IEEE24765}.
\end{defn}
\begin{defn}Interoperability is a characteristic of a product or system, whose
	interfaces are completely understood, to work with other products or systems,
	present or future, in either implementation or access, without any restrictions
	\citep{AFUL2019}.
\end{defn}
\begin{defn}
	Interoperability is the ability of different information systems, devices and
	applications (‘systems’) to access, exchange, integrate and cooperatively use
	data in a coordinated manner, within and across organizational, regional and
	national boundaries, to provide timely and seamless portability of information
	and optimize the health of individuals and populations globally. Health data
	exchange architectures, application interfaces and standards enable data to be
	accessed and shared appropriately and securely across the complete spectrum of
	care, within all applicable settings and with relevant stakeholders, including
	by the individual \citep{HIMSS2019}.
	
	Four Levels of Interoperability:
	\begin{itemize}
		\item Foundational (Level 1) – establishes the inter-connectivity requirements
		needed for one system or application to securely communicate data to and receive
		data from another
		
		\item Structural (Level 2) – defines the format, syntax, and organization of
		data exchange including at the data field level for interpretation
		
		\item Semantic (Level 3) – provides for common underlying models and
		codification of the data including the use of data elements with standardized
		definitions from publicly available value sets and coding vocabularies,
		providing shared understanding and meaning to the user
		
		\item Organizational (Level 4) – includes governance, policy, social, legal and
		organizational considerations to facilitate the secure, seamless and timely
		communication and use of data both within and between organizations, entities
		and individuals. These components enable shared consent, trust and integrated
		end-user processes and workflows
	\end{itemize}
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{InteroperabilitySelected}.

\noindent \textbf{Reasoning}

This definition is concise and also detailed enough to show the concept not only
on system, but also on products and components. It also covered the concept with
more than 2 systems.

\subsection{\notdone{Visibility/Transparency} \ad{owner}}

\begin{defn}
	\label{VisibilitySelected}
	A software development process is visible if all of its steps and its current
	status are documented clearly. Another term used to characterize this property
	is transparency \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn}
	Visibility provides transparency into the development process. It is the ability
	to see progress at any point and determine the distance to completion of a goal.
	Visibility provides status of not only the progress of the project, but the
	product itself \citep{GSA2019}.
\end{defn}

\begin{defn}
	Business process visibility, also called process visibility, is the ability to
	accurately and completely view the processes, transactions and other activities
	operating within an enterprise \citep{Rouse2013}.
\end{defn}

\begin{defn}
	Process transparency refers to the ability to look inside. The “look inside”
	provides an in-depth and clear visibility into the business processes and how
	these operate \citep{PRIME2019}.
\end{defn}

\noindent \textbf{Proposed Definition} 

Definition \ref{VisibilitySelected} rephrased: The extent to which all of the
steps and the current status of a software development process are documented
clearly.

\noindent \textbf{Reasoning}

Definition \ref{VisibilitySelected} points out that documentation is the way to
improve visibility. It is
rephrased because the original one might refer to binary status - ``visible'' or
``unvisible''.

\subsection{\notdone{Reproducibility} \wss{owner}}

Reproducibility is a required component of the scientific
method \citep{Davison2012}.  Although QA has, ``a bad name among creative
scientists and engineers'' \citep[p.~352]{Roache1998}, the community need to
recognize that participating in QA management also improves reproducibility.
Reproducibility, like QA, benefits from a consistent and repeatable computing
environment, version control and separating code from
configuration/parameters \citep{Davison2012}.

Reproducibility is defined as:

\begin{defn}
	A result is said to be reproducible if another researcher can take the original
	code and input data, execute it, and re-obtain the same result (Peng, Dominici,
	and Zeger, 2006), as cited in \citet{BenureauAndRougier2017}.
\end{defn}

The related concept of replicable is defined as:

\begin{defn}
	Documentation achieves replicability if the description it provides of the
	algorithms is sufficiently precise and complete for an independent researcher to
	re-obtain the results it presents.  \citep{BenureauAndRougier2017}
\end{defn}

It would be worthwhile to look for some additional definitions.

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Productivity} \ad{owner}}

\begin{defn}
	A quality of the software production process, referring to its efficiency and
	performance \citep{ghezzi1991fundamentals}.
\end{defn}
\begin{defn}
	The best definition of the productivity of a process is
	\[\text{Productivity} = \dfrac{\text{Outputs produced by the
			process}}{\text{Inputs consumed by the process}}\] Defining inputs. For
	the software process, providing a meaningful definition of inputs is a
	nontrivial but generally workable problem. Inputs to the software process
	generally comprise labor, computers, supplies, and other support facilities and
	equipment. Defining outputs. The big problem in defining software productivity
	is defining outputs. Here we find a defining delivered source instructions (DSI)
	or lines of code as the output of the software process is totally inadequate,
	and they argue that there are a number of deficiencies in using DSI. However,
	most organizations doing practical productivity measurement still use DSI as
	their primary metric \citep{Boehm1987}. \wss{Is this a direct quote from
		\citet{Boehm1987}?  The sentences seem incomplete?}
\end{defn}
\begin{defn}
	\label{ProductivitySelected}
	Productivity is the amount of output (what is produced) per unit of input
	used. If we can measure the size of the software product and the effort required
	to develop the product, we have:
	\begin{align}
	\text{productivity} = \text{size}/\text{effort}
	\end{align}
	Equation (1) assumes that size is the output of the software production process
	and effort is the input to the process. This can be contrasted with the
	viewpoint of software cost models where we use size as an independent variable
	(i.e., an input) to predict effort which is treated as an output. Equation (1)
	is simple to operationalize if we have a single dominant size measure, for
	example, product size measured in lines of code \citep{Kitchenham2004}.
\end{defn}

\noindent \textbf{Proposed Definition} 

The first sentence of Definition \ref{ProductivitySelected}: Productivity is the
amount of output (what is produced) per unit of input used.

\noindent \textbf{Reasoning}

It is concise and measurable. \wss{What is the output?  What is the input?  I
	think the definition needs to give more information on these.  In particular,
	the above definitions focus on code as the output, but documentation, test
	cases etc should also be part of the output.  If we are going to measure this,
	we need a better idea of what we are measuring for outputs and inputs.}

\subsection{\notdone{Sustainability} \wss{owner}}

One of the original definitions of sustainability (for systems, not software
specific), and still often quoted, is:

\begin{defn}
	\noindent The ability to meet the needs of the present without compromising the
	ability of
	future generations to meet their own needs \citep{Brundtland1987}.
\end{defn}

This is the definition used by \citet{IISD2019}.

To make it more useful, this definition is often split into three dimensions:
social, economic and environmental. \wss{cite UN paper [9] in
	\citet{PenzenstadlerAndHenning2013}}  To this list Penzenstadler and Henning
(2013) have added technical sustainability \citep{PenzenstadlerAndHenning2013}.
Where technical sustainability for software is defined as:

\begin{defn}
	\noindent Technical sustainability has the central objective of long-time
	usage of systems and their adequate evolution with changing surrounding
	conditions and respective requirements \citep{PenzenstadlerAndHenning2013}.
\end{defn}

The fourth dimension of technical sustainability is also added
by \citep{WolframEtAl2017}.  Technical sustainability is the focus on the thesis
by \citet{Hygerth2016}.

\begin{defn}
	\noindent Sustainable development is a mindset (principles) and an
	accompanying set of practices that enable a team to achieve and maintain an
	optimal development pace indefinitely \citep{Tate2005}.
\end{defn}

Parnas discusses as software aging \citep{Parnas1994a}.

SCS specific definitions:

\begin{defn}
	The concept of sustainability is based on three pillars: the
	ecological, the economical and the social. This means that for a software to
	be sustainable, we must take all of its effects -- direct and indirect -- on
	the environment, the economy and the society into account. In addition, the
	entire life cycle of a software has to be considered: from planning and
	conception to programming, distribution, installation, usage and
	disposal \citep{Heine2017}.
\end{defn}

\begin{defn}
	\noindent The capacity of the software to endure. In other words,
	sustainability means that the software will continue to be available in the
	future, on new platforms, meeting new needs \citep{Katz2016}.
\end{defn}

Definition from Neil Chue Hong:
\begin{defn}
	Sustainable software is software which is:
	-- Easy to evolve and maintain
	-- Fulfils its intent over time
	-- Survives uncertainty
	-- Supports relevant concerns (Political, Economic, Social, Technical,
	Legal, Environmental) \citep{Katz2016}.
\end{defn}

Paper critical of a lack of a definition \citep{VentersEtAl2014}.

Sounds like definition of maintainability.

Find paper that combines nonfunctional qualities into sustainability.

Sustainability depends on the software artifacts AND the software team AND the
development process.

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\section{Desirable Qualities of Good Specifications} \label{SecDesirableQs}

To achieve the qualities listed in Section~\ref{SecQualities}, the documentation
should achieve the qualities listed in this section.  All but the final quality
listed (abstraction), are adapted from the IEEE recommended practise for
producing good software requirements \citep{IEEE1998}.  Abstraction means only
revealing relevant details, which in a requirements document means stating what
is to be achieved, but remaining silent on how it is to be achieved.
Abstraction is an important software development principle for dealing with
complexity \citep[p.~40]{GhezziEtAl2003}.  Correctness was in the above list, so
it is not repeated here.  \citet{SmithAndKoothoor2016} present further details
on the qualities of documentation for SCS.

\subsection{\notdone{Completeness} \ad{owner}}

\begin{defn}
	\label{CompletenessSelected}
	A specification is complete to the extent that all of its parts are present and
	each part is fully developed. A software specification must exhibit several
	properties to assure its completeness \citep{Boehm1984}:
	\begin{itemize}
		\item No TBDs. TBDs are places in the specification where decisions have been
		postponed by writing "To be Determined" or "TBD."
		\item No nonexistent references. These are references in the specification to
		functions, inputs, or outputs (including databases) not defined in the
		specification.
		\item No missing specification items. These are items that should be present as
		part of the standard format of the specification, but are not present.
		\item No missing functions. These are functions that should be part of the
		software product but are not called for in the specification.
		\item No missing products. These are products that should be part of the
		delivered software but are not called for in the specification.
	\end{itemize}
\end{defn}

\wss{Were there any other definitions of completeness?  You could add the
	definition of completeness from \citet[p.\ 5--6]{IEEE1998}.  This definition
	is for
	requirements, but maybe there is something we can generalize from the
	definition?  We could also look for definitions outside of software
	development.}

\noindent \textbf{Proposed Definition} 

The first sentence of Definition \ref{CompletenessSelected}: A specification is
complete to the extent that all of its parts are present and each part is fully
developed.

\noindent \textbf{Reasoning}

It is concise and measurable.

\subsection{\notdone{Consistency} \ad{owner}}

\begin{defn}
	\label{ConsistencySelected}
	A specification is consistent to the extent that its provisions do not conflict
	with each other or with governing specifications and objectives. Specifications
	require consistency in several ways \citep{Boehm1984}.
	\begin{itemize}
		\item Internal consistency. Items within the specification do not conflict with
		each other.
		\item External consistency. Items in the specification do not conflict with
		external specifications or entities.
		\item Traceability. Items in the specification have clear antecedents in earlier
		specifications or statements of system objectives.
	\end{itemize}
\end{defn}
\begin{defn}
	Consistency requires that no two or more requirements in a specification
	contradict each other. It is also often regarded as the case where words and
	terms have the same meaning throughout the requirements specifications
	(consistent use of terminology). These two views of consistency imply that
	mutually exclusive statements and clashes in terminology should be avoided
	\citep{ZOWGHI2003}.
\end{defn}
\begin{defn}
	Consistency: 1. the degree of uniformity, standardization, and freedom from
	contradiction among the documents or parts of a system or component 2. software
	attributes that provide uniform design and implementation techniques and
	notations \citep{ISO/IEC/IEEE24765}.
\end{defn}

\wss{The definition from \citet{IEEE1998} might again be useful.  We could also
	look for definitions outside of software development.  Even a dictionary
	definition could be helpful.}

\noindent \textbf{Proposed Definition} 

The first sentence of Definition \ref{ConsistencySelected}: A specification is
consistent to the extent that its provisions do not conflict with each other or
with governing specifications and objectives.

\noindent \textbf{Reasoning}

It is concise and measurable.

\subsection{\notdone{Modifiability} \jc{owner}}

Here we do seem to have a simple, if somewhat uninformative, definition:

\begin{defn}
	Modifiability is the degree of ease at which changes can be made to a system,
	and the flexibility with which the system adapts to such changes.
\end{defn}

IEEE Standard 610 seems to speak about this. (which is superseded?)

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Traceability} \jc{owner}}

Here the Wikipedia page~\url{https://en.wikipedia.org/wiki/Traceability} is
actually rather informative, especially as it also lists how this concept is
used in other domains.  A generic definition that is still quite useful is
\begin{defn}
	The capability (and implementation) of keeping track of a given set or type of
	information to a given degree, or the ability to chronologically interrelate
	uniquely identifiable entities in a way that is verifiable.
\end{defn}
By specializing the above to software artifacts, ``interrelate'' to 
``why is this here'' (for forward tracing from requirements), this does
indeed give what is meant in SE.

Various standards (DO178C, ISO 26262, and IEC61508) explicitly mention it.

24765-2017 - ISO/IEC/IEEE International Standard - Systems and software
engineering--Vocabulary
has a full definition, namely
\begin{enumerate}
	\item the degree to which a relationship can be established between two or more
	products of the development process, especially products having a
	predecessor-successor or master-subordinate relationship to one another;
	\item
	the identification and documentation of derivation paths (upward) and
	allocation or flowdown paths (downward) of work products in the work product
	hierarchy;
	\item the degree to which each element in a software development
	product establishes its reason for existing; and discernible association
	among two or more logical entities, such as requirements, system elements,
	verifications, or tasks.
\end{enumerate}

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed.}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Unambiguity} \wss{owner}}

A specification is unambiguous when it has a unique interpretation.  If there is
a possibility that two readers will have two different interpretations, than the
specification is ambiguous.  \wss{When I get the Ghezzi text back from Olu, I'll
	check to see if they have anything to add to this definition.}

A Software Requirements Specification (SRS) is unambiguous if, and only if,
every requirement stated therein has only one interpretation \citep{IEEE1998}.

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed.}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Verifiability} \wss{owner}}

\begin{itemize}
	
	\item Verification - Are we building the product right?  Are we implementing the
	requirements correctly (internal)
	\item Validation - Are we building the right product? Are we getting the right
	requirements (external)
	\item According to
	
	\href{https://en.wikipedia.org/wiki/Software_verification_and_validation}{Capability
		Maturity Model (CMM)}
	\begin{itemize}
		\item 
		Software Verification: The process of evaluating software to determine
		whether the products of a given development phase satisfy the conditions
		imposed at the start of that phase. [IEEE-STD-610] \wss{Need a proper
			citation}
		\item Software Validation: The process of evaluating software during or at the
		end of the development process to determine whether it satisfies specified
		requirements. [IEEE-STD-610] \wss{Need a proper citation}
	\end{itemize}
\end{itemize}

``An SRS is verifiable if, and only if, every requirement stated therein is
verifiable. A requirement is verifiable if, and only if, there exists some
finite cost-effective process with which a person or machine can check that the
software product meets the requirement. In general any ambiguous requirement is
not verifiable.'' \citep{IEEE1998}

Verifiability is related to testability, which is defined by McCall et al.\ as
``The effort required to test a program to ensure that it performs its intended
function'' \citep{VanVliet2000}.  

\wss{When I get the Ghezzi text back from Olu,
	I'll check to see if they have anything to add to this definition.}

\begin{defn}
	A software system is verifiable if its properties can be verified easily
	\citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Abstract} \wss{owner}}

\begin{defn}
	Documented requirements are said to be abstract if they state what the software
	must do and the properties it must possess, but do not speak about how these are
	to be achieved \citep{GhezziEtAl2003}.  
\end{defn}

\begin{defn}
	``An abstraction for a software artifact is a succinct description that
	suppresses
	the details that are unimportant to a software developer and emphasizes the
	information that is important.'' \citep{Krueger1992}
\end{defn}

\begin{defn}
	``Abstraction means that we concentrate on the essential features and ignore,
	abstract from, details that are not relevant at the level we are currently
	working.''  \citep[p.\ 296]{VanVliet2000}
\end{defn}

\begin{defn}
	``Abstraction in mathematics is the process of extracting the underlying essence
	of a mathematical concept, removing any dependence on real world objects with
	which it might originally have been connected, and generalizing it so that it
	has wider applications or matching among other abstract descriptions of
	equivalent phenomena.''
	\href{https://en.wikipedia.org/wiki/Abstraction_(mathematics)} {Wikipedia
		Definition}
\end{defn}

Abstraction is related to reusability (and other qualities).

\wss{When I get the Ghezzi text back from Olu, I'll check to see if they have
	anything to add to this definition.}

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../CommonFiles/ResearchProposal}

\end{document}

