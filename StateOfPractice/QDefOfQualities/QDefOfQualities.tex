\documentclass[12pt]{article}

\usepackage[round]{natbib}
\usepackage{booktabs}
\usepackage{amsmath}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links (change box color with linkbordercolor)
    citecolor=blue,       % color of links to bibliography
    filecolor=magenta,   % color of file links
    urlcolor=cyan           % color of external links
}

%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}} %Spencer Smith
\newcommand{\jc}[1]{\authornote{red}{JC}{#1}} %Jacques Carette
\newcommand{\oo}[1]{\authornote{magenta}{OO}{#1}} %Olu Owojaiye
\newcommand{\pmi}[1]{\authornote{green}{PM}{#1}} %Peter Michalski
\newcommand{\ad}[1]{\authornote{cyan}{AD}{#1}} %Ao Dong

%\oddsidemargin 0mm
%\evensidemargin 0mm
%\textwidth 160mm
%\textheight 200mm

\begin{document}

\title{Quality Definitions of Qualities} 
\author{Spencer Smith, Jacques Carette, Olu Owojaiye,\\Peter Michalski and Ao Dong}
\date{\today}
	
\maketitle

\begin{abstract}
  ...
\end{abstract}

\tableofcontents

\newpage

\section{Introduction} \label{SecIntroduction}

Purpose and scope of the document.  \wss{Needs to be filled in.  Should
  reference the overal research proposal, and the ``state of the practice''
  exercise in particular.}

The presentation is divided into two main sections: i) qualities that apply to software products,
software artifacts and software development processes, and ii) qualities that
are considered important for good specifications.  The specification could be a
specification of requirements, design or a test plan.  

\section{Qualities of Software Products, Artifacts and
  Processes} \label{SecQualities}

To assess the current state of software development, and to understand how
future changes impact software development, we need a clear definition of what
we mean by quality.  The concept of quality is decomposed into a set of separate
qualities.  This set of qualities can be applied to the software product, the
software artifacts (documentation, test cases, etc) and to the software
development process itself.

Our analysis is centred around a set of software qualities.  Quality is not
considered as a single measure, but a collection of different qualities, often
called ``ilities.''  These qualities highlight the desirable nonfunctional
properties for software artifacts, which include both documentation and
code. Some qualities, such as visibility and productivity, apply to the process
used for developing the software. The following list of qualities is based on
\cite{GhezziEtAl2003}. To the list from \cite{GhezziEtAl2003}, we have added
three qualities important for SC: installability, reproducibility and
sustainability.

\subsection{Installability}

A measure of the ease of installation.


\subsection{Correctness}

Software is correct if it matches its specification.  There is no direct tool or
method for measuring correctness. One way of building confidence in correctness
is by reviewing to ensure that each requirement stated is one that the
stakeholders and experts desire.  By maintaining traceability, consistency and
unambiguity, we can reduce the occurrence of errors and make the goal of
reviewing for correctness easier.

\subsection{Verifiability}

Verifiability involves ``solving the equations right''~\cite[p.~23]{Roache1998};
it benefits from rational documentation that systematically shows, with explicit
traceability, how the governing equations are transformed into code.

\subsection{Validatability}

Validatability means ``solving the right equations''~\cite[p.~23]{Roache1998}.
Validatability is improved by a rational process via clear documentation of the
theory and assumptions, along with an explicit statement of the systematic steps
required for experimental validation.

\subsection{Reliability}

Reliability is a critical quality for scientific software, since the results of
computations are meaningless, if they are not dependable.  Reliability is
closely tied to verifiability, since the key quality to verify is reliability,
while the act of verification itself improves reliability.

\subsection{Robustness}
The degree to which a system or component can function correctly in the presence of invalid inputs or stressful environmental conditions \cite{IEEEStdGlossarySET1990}.
The quality can be further informally refined as the ability of a software to keep an acceptable behavior, expressed in terms of robustness requirements, in spite of exceptional or unforeseen execution conditions (such as the unavailability of system resources, communication failures, invalid or stressful inputs, etc.) \cite{fernandez2005model}.

\subsection{Performance}

The degree to which a system or component accomplishes its designated functions within given constraints, such as speed, accuracy, or memory usage \cite{IEEEStdGlossarySET1990}.
Performance considerations can make certification challenging, since QA becomes more difficult for more complex code.  However, as Roache~\cite[p.~355]{Roache1998} points out, using simpler algorithms and reducing the number of options in general purpose code, is not always a practical option.

\subsection{Usability}

Usability can be a problem.  Different users, solving the same physical problem,
using the same software, can come up with different answers, due to differences
in parameter selection~\cite[p.~370]{Roache1998}.  To reduce misuse, a rational
process must state expected user characteristics, modelling assumptions,
definitions and the range of applicability of the code.

\subsection{Maintainability}

The ease with which a software system or component can be modified to correct faults, improve performance or other attributes, or adapt to a changed environment \cite{IEEEStdGlossarySET1990}. ISO/IEC 25010 refers to maintainability as the degree of effectiveness and efficiency with which a product or system can be modified by the intended maintainers \cite{ISO/IEC25010}.
Maintainability is necessary in scientific software, since change, through iteration, experimentation and exploration, is inevitable.  Models of physical phenomena and numerical techniques necessarily evolve over time~\cite{CarverEtAl2007, SegalAndMorris2008}.  Proper documentation, designed with change in mind, can greatly assist with change management.  QA activities need to take the need for creativity into account, while not smothering
it~\cite[p.~352]{Roache1998}.

\subsection{Reusability}

The degree to which a software module or other work product can be used in more than one software system \cite{IEEEStdGlossarySET1990}. Reusability provides support for the quality of reliability, since reliability
is improved by reusing trusted components~\cite{Dubois2005}.  (Care must still
be taken with reusing trusted components, since blind reuse in a new context can lead to errors, as dramatically shown in the Ariane 5 disaster~\cite[p.~37--38]{OliveiraAndStewart2006}.)  The odds of reuse are improved when it is considered right from the start.

\subsection{Portability}

The ease with which a system or component can be transferred from one hardware or software environment to another \cite{IEEEStdGlossarySET1990}. An application is portable across a class of environments to the degree that the effort required to transport and adapt it to a new environment in the class is less than the effort of redevelopment \cite{mooney1990strategies}.
 

\subsection{Understandability}

Understandability is necessary, since reviewers can only certify something they
understand.  Scientific software developers have the view ``that the science a
developer embeds in the code must be apparent to another scientist, even ten
years later''~\cite{Kelly2013}.  Understandability applies to the documentation
and code, while usability refers to the executable software.  Documentation that
follows a rational process is the easiest to follow.

\subsection{Interoperability}

\begin{quotation}
	\noindent Interoperability is the ability of two or more systems or components to exchange information and to use the information that has been exchanged~\cite{IEEE1991}.
	\noindent The degree to which two or more systems, products or components can exchange information and use the information that has been exchanged~\cite{ISO/IEC25010}.
	\noindent The capability to communicate, execute programs, and transfer data among various functional units in a manner that requires the user to have little or no knowledge of the unique characteristics of those units~\cite{ISO/IEC/IEEE24765}.
	\noindent Interoperability is a characteristic of a product or system, whose interfaces are completely understood, to work with other products or systems, present or future, in either implementation or access, without any restrictions~\cite{AFUL}.
\end{quotation}

\subsection{Visibility/Transparency}
    \ad{I found little contents related to visibility or transparency. The following definition is the only one I could find, but may be irrelevant to this project.}
    \begin{quotation}
        1. the degree to which a transaction can access object state concurrently with other transactions. 2. the specification, for a property, of "who can see it?"~\cite{ISO/IEC/IEEE24765}
    \end{quotation}
\subsection{Reproducibility}

Reproducibility is a required component of the scientific
method~\cite{Davison2012}.  Although QA has, ``a bad name among creative
scientists and engineers''~\cite[p.~352]{Roache1998}, the community need to
recognize that participating in QA management also improves reproducibility.
Reproducibility, like QA, benefits from a consistent and repeatable computing
environment, version control and separating code from
configuration/parameters~\cite{Davison2012}.

\subsection{Productivity}

\begin{quotation}
    The best definition of the productivity of a process is
    \[Productivity = \dfrac{Outputs\ produced\ by\ the\ process}{Inputs\ consumed\ by\ the\ process}\]
    Defining inputs. For the software process, providing a meaningful definition of inputs is a nontrivial but generally workable problem. Inputs to the software process generally comprise labor, computers, supplies, and other support facilities and equipment. Defining outputs. The big problem in defining software productivity is defining outputs. Here we find a paradox. Most sources say that defining delivered source instructions (DSI) or lines of code as the output of the software process is totally inadequate, and they argue that there are a number of deficiencies in using DSI. However, most organizations doing practical productivity measurement still use DSI as their primary metric~\cite{Boehm1987}.\\

    \smallskip
    Productivity is the amount of output (what is produced) per unit of input used.If we can measure the size of the software product and the effort required to develop the product, we have:
    \begin{align}
        productivity = size/effort
    \end{align}
    Equation (1) assumes that size is the output of the software production process and effort is the input to the process. This can be contrasted with the viewpoint of software cost models where we use size as an independent variable (i.e., an input) to predict effort which is treated as an output. Equation (1) is simple to operationalize if we have a single dominant size measure, for example, product size measured in lines of code~\cite{Kitchenham2004}.
\end{quotation}

\subsection{Sustainability}

One of the original definitions of sustainability (for systems, not software
specific), and still often quoted, is:

\begin{quotation}
\noindent The ability to meet the needs of the present without compromising the ability of
future generations to meet their own needs \cite{Brundtland1987}.
\end{quotation}

This is the definition used by~\cite{IISD2019}.

To make it more useful, this definition is often split into three dimensions:
social, economic and environmental. \wss{cite UN paper [9] in
  \cite{PenzenstadlerAndHenning2013}}  To this list Penzenstadler and Henning
(2013) have added technical sustainability \cite{PenzenstadlerAndHenning2013}.
Where technical sustainability for software is defined as:

\begin{quotation}
\noindent Technical sustainability has the central objective of long-time
usage of systems and their adequate evolution with changing surrounding
conditions and respective requirements \cite{PenzenstadlerAndHenning2013}.
\end{quotation}

The fourth dimension of technical sustainability is also added
by~\cite{WolframEtAl2017}.  Technical sustainability is the focus on the thesis
by~\cite{Hygerth2016}.

\begin{quotation}
  \noindent Sustainable development is a mindset (principles) and an
  accompanying set of practices that enable a team to achieve and maintain an
  optimal development pace indefinitely~\cite{Tate2005}.
\end{quotation}

Parnas discusses as software aging~\cite{Parnas1994a}.

SCS specific definitions:

\begin{quotation}
  \noindent The concept of sustainability is based on three pillars: the
  ecological, the economical and the social. This means that for a software to
  be sustainable, we must take all of its effects -- direct and indirect -- on
  the environment, the economy and the society into account. In addition, the
  entire life cycle of a software has to be considered: from planning and
  conception to programming, distribution, installation, usage and
  disposal~\cite{Heine2017}.
\end{quotation}

\begin{quotation}
  \noindent The capacity of the software to endure. In other words,
  sustainability means that the software will continue to be available in the
  future, on new platforms, meeting new needs~\cite{Katz2016}.
\end{quotation}

Definition from Neil Chue Hong:
\begin{quotation}
\noindent Sustainable software is software which is:
-- Easy to evolve and maintain
-- Fulfils its intent over time
-- Survives uncertainty
-- Supports relevant concerns (Political, Economic, Social, Technical,
Legal, Environmental)~\cite{Katz2016}.
\end{quotation}

Paper critical of a lack of a definition~\cite{VentersEtAl2014}.

Sounds like definition of maintainability.

Find paper that combines nonfunctional qualities into sustainability.

Sustainability depends on the software artifacts AND the software team AND the
development process.

\section{Desirable Qualities of Good Specifications} \label{SecDesirableQs}

To achieve the qualities listed in Section~\ref{SecQualities}, the documentation
should achieve the qualities listed in this section.  All but the final quality
listed (abstraction), are adapted from the IEEE recommended practise for
producing good software requirements~\cite{IEEE1998}.  Abstraction means only
revealing relevant details, which in a requirements document means stating what
is to be achieved, but remaining silent on how it is to be achieved.
Abstraction is an important software development principle for dealing with
complexity~\cite[p.~40]{GhezziEtAl2003}.  Correctness was in the above list, so
it is not repeated here.  \citet{SmithAndKoothoor2016} present further details
on the qualities of documentation for SCS.

\subsection{Completeness}

Documentation is said to be complete when all the requirements of the software
are detailed. That is, each goal, functionality, attribute, design constraint,
value, data, model, symbol, term (with its unit of measurement if applicable),
abbreviation, acronym, assumption and performance requirement of the software is
defined.  The software's response to all classes of inputs, both valid and
invalid and for both desired and undesired events, also needs to be specified.

\begin{quotation}
    A specification is complete to the extent that all of its parts are present and each part is fully developed. A software specification must exhibit several properties to assure its completeness:
    \begin{itemize}
        \item No TBDs. TBDs are places in the specification where decisions have been postponed by writing "To be Determined" or "TBD."
        \item No nonexistent references. These are references in the specification to functions, inputs, or outputs (including databases) not defined in the specification.
        \item No missing specification items. These are items that should be present as part of the standard format of the specification, but are not present.
        \item No missing functions. These are functions that should be part of the software product but are not called for in the specification.
        \item No missing products. These are products that should be part of the delivered software but are not called for in the specification.~\cite{Boehm1984}.
    \end{itemize}

\end{quotation}

\subsection{Consistency}

Documentation is said to be consistent when no subset of individual statements
are in conflict with each other. That is, a specification of an item made at one
place in the document should not contradict the specification of the same item
at another location.

\begin{quotation}
    A specification is consistent to the extent that its provisions do not conflict with each other or with governing specifications and objectives. Specifications require consistency in several ways.
    \begin{itemize}
        \item Internal consistency. Items within the specification do not conflict with each other.
        \item External consistency. Items in the specification do not conflict with external specifications or entities.
        \item Traceability. Items in the specification have clear antecedents in earlier specifications or statements of system objectives~\cite{Boehm1984}.
    \end{itemize}
    Consistency requires that no two or more requirements in a specification contradict each other. It is also often regarded as the case where words and terms have the same meaning throughout the requirements specifications (consistent use of terminology). These two views of consistency imply that mutually exclusive statements and clashes in terminology should be avoided~\cite{ZOWGHI2003}. Consistency: 1. the degree of uniformity, standardization, and freedom from contradiction among the documents or parts of a system or component 2. software attributes that provide uniform design and implementation techniques and notations~\cite{ISO/IEC/IEEE24765}
\end{quotation}

\subsection{Modifiability}

The documentation should be developed in such a way that it is easily modifiable
so that likely future changes do not destroy the structure of the document. Also
it should be easy to reflect the change, wherever needed in the document to
maintain consistency, traceability and completeness. For documentation to be
modifiable, its format must be structured in a way that repetition is avoided
and cross-referencing is employed.

\subsection{Traceability}

Documentation should be traceable, as this facilitates maintenance and
review. If a change is made to the design or code of the software, then all the
documentation relating to those segments have to be modified.  This property is
also important for recertification.

\subsection{Unambiguity}

Documentation is said to be unambiguous only when every requirement's
specification has a unique interpretation.  The documentation should be
unambiguous to all audiences, including developers, users and reviewers.

\subsection{Verifiability}

Every requirement in the documentation must be the one fulfilled by the
implemented software. Therefore all the requirements should be clear,
unambiguous and testable, so that a person or a machine can verify whether the
software product meets the requirements.

\subsection{Abstract}

Documented requirements are said to be abstract if they state what the software
must do and the properties it must possess, but do not speak about how these are
to be achieved. For example, a requirement can specify that an Ordinary
Differential Equation (ODE) must be solved, but it should not mention that
Euler's method should be used to solve the ODE. How to accomplish the
requirement is a design decision, which is documented during the design phase.

\newpage

\bibliographystyle {plainnat}
\bibliography {../../CommonFiles/ResearchProposal}

\end{document}
