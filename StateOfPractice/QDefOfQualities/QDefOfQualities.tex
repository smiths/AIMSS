\documentclass[letterpaper,cleveref]{lipics-v2019}

\usepackage{natbib}
\usepackage{booktabs}
\usepackage{amsmath,amsthm}

\usepackage{hyperref}
\hypersetup{
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with
%linkbordercolor)
citecolor=blue,       % color of links to bibliography
filecolor=magenta,   % color of file links
urlcolor=cyan           % color of external links
}

%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}} %Spencer Smith
\newcommand{\jc}[1]{\authornote{red}{JC}{#1}} %Jacques Carette
\newcommand{\oo}[1]{\authornote{magenta}{OO}{#1}} %Olu Owojaiye
\newcommand{\pmi}[1]{\authornote{green}{PM}{#1}} %Peter Michalski
\newcommand{\ad}[1]{\authornote{cyan}{AD}{#1}} %Ao Dong

\newcommand{\notdone}[1]{\textcolor{red}{#1}}
\newcommand{\done}[1]{\textcolor{black}{#1}}

%\oddsidemargin 0mm
%\evensidemargin 0mm
%\textwidth 160mm
%\textheight 200mm

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\title{Quality Definitions of Qualities} 
\author{Spencer Smith}{McMaster University, Canada}{smiths@mcmaster.ca}{}{}
\author{Jacques Carette}{McMaster University, Canada}{carette@mcmaster.ca}{}{}
\author{Olu Owojaiye}{McMaster University, Canada}{owojaiyo@mcmaster.ca}{}{}
\author{Peter Michalski}{McMaster University, Canada}{michap@mcmaster.ca}{}{}
\author{Ao Dong}{McMaster University, Canada}{donga9@mcmaster.ca}{}{}

\authorrunning{Smith et al.}  \Copyright{Spencer Smith and Jacques Carette and
Olu Owojaiye and Peter Michalski and Ao Dong}

\date{\today}

\hideLIPIcs
\nolinenumbers

\begin{document}
\maketitle

\begin{abstract}
	...
\end{abstract}

\tableofcontents

\section{Introduction} \label{SecIntroduction}

Purpose and scope of the document.  \wss{Needs to be filled in.  Should
	reference the overall research proposal, and the ``state of the practice''
	exercise in particular.}

The presentation is divided into two main sections: i) qualities that apply to
software products, software artifacts and software development processes, and
ii) qualities that are considered important for good specifications.  The
specification could be a specification of requirements, design or a test plan.

The pattern in the presentation for each of the qualities is the same.  First we
summarize all of the definitions that we could find in the literature.  To keep
the clutter of quotation marks down, we have adopted the convention that each
definition is given verbatim from the cited source, but without showing
quotation marks.  In cases where the definition has to be rephrased, quotation
marks are used to show those portions that are taken verbatim for the original
source.  After the summary of the existing definitions, we propose the
definition that we would like to work with going forward.  This definition can
either be our preference from the existing definitions, or a new definition,
which is often found by combining existing definitions.  Following the proposed
definition is an explanation for the reasoning that led to this choice.

In determining our recommended definition for each quality, we used the
following criteria:

\begin{description}
\item[Consistency] The final list of definitions should be consistent in the
  terminology used.  For instance, we do not use synonyms for variety; we use
  the same word to mean the same concept throughout the final list of
  definitions.  This is why measurement is given by ``the effort required..''
  and not the various synonyms for this that are seen in the literature. \wss{We
    may change this phrase we use for measuring something.  I just wanted to put
    this in here as a placeholder.}
\item[Generality]
\item[Measurability]
\item[Etc.]
\end{description}

\section{Qualities of Software Products, Artifacts and
	Processes} \label{SecQualities}

To assess the current state of software development, and to understand how
future changes impact software development, we need a clear definition of what
we mean by quality.  The concept of quality is decomposed into a set of separate
components that together make up ``quality''. Unfortunately, these are
called \emph{qualities}. These are associated to the software product,
the software artifacts (documentation, test cases, etc) and to the software
development process itself, and combinations thereof.

Our analysis is centred around a set of software qualities.  Quality is not
considered as a single measure, but a collection of different qualities, often
called ``ilities.''  These qualities highlight the desirable nonfunctional
properties for software artifacts, which include both documentation and
code. Some qualities, such as visibility and productivity, apply to the process
used for developing the software. The following list of qualities is based on
\cite{GhezziEtAl2003}. To the list from \cite{GhezziEtAl2003}, we have added
three qualities important for SC: installability, reproducibility and
sustainability.

\subsection{{Installability} \oo{owner}}

\begin{defn}
  The capability of the software product to be installed in a specified
  environment \citep{ISO9126}.
\end{defn}

\begin{defn} \label{Installability_Selected2}
	The degree of effectiveness and efficiency with which a product or system can
	be successfully installed and/or uninstalled in a specified environment
	\citep{ISO/IEC25010}.
\end{defn}

\begin{defn} \label{Installability_Selected1} Installability refers to the cost
  or effort required for the installation, given an installation is possible to
  begin with \citep{lenhard2013measuring}.
\end{defn}

\noindent \textbf{Proposed Definition}

Combined definitions \ref{Installability_Selected2} and
\ref{Installability_Selected1} rephrased:
 Installability refers to the
effort required for the installation, uninstallation or reinstallation of a
software or product in a specified environment.

\noindent \textbf{Reasoning}

 The definition captures a vital metric of measure for this quality - 
 effort, and considers not just the installation but uninstallation
 and re-installation which are all related to installation activities.

\subsection{{Correctness} \oo{owner}}

\begin{defn} \label{Correctness_Selected}
  A program is functionally correct if it behaves according to its stated
  functional specifications \citep{GhezziEtAl2003}.  	
\end{defn}

\begin{defn}
  The degree to which a system is free from faults in its specification, design, and 
  implementation \citep{mcconnell2004code}.
\end{defn}

\begin{defn}
  The ability of software products to perform their exact tasks, as defined by
  their specification \citep{meyer1988object}.
\end{defn}

\begin{defn} 
  The extent to which a program satisfies its specifications and fulfills the
  user's mission objectives \citep{McCallEtAl1977}. 
\end{defn}

\begin{defn}  
  The degree to which a system or component is free from faults in its
  specification, design and implementation \citep{IEEEComputerDictionary1991}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition~\ref{Correctness_Selected} rephrased: A program is correct if it
behaves according to its stated specifications.

\noindent \textbf{Reasoning}

To determine whether a program is correct, we must be able to refer to both its
specification, design and implementation to understand the intended purpose and
this definition captures it all.

\subsection{\notdone{Verifiability} \oo{owner}}

\begin{defn}
	Verification involves solving the equations right \citep[p.~23]{Roache1998}.
\end{defn}

\begin{defn}
  A software is verifiable if its properties can be verified easily
  \citep{GhezziEtAl2003}.  \wss{Is this a direct quote?} \oo{yes}
\end{defn}

\begin{defn} \label{Defn_Verifiability1}
Verifiability ``means that you should be able to write a set of tests that can
demonstrate that the delivered system meets each specified requirement'' \citep{sommerville}.	
\end{defn}

\begin{defn}
	The evaluation of whether or not a product, service, or result complies with
	a regulation, requirement, specification, or imposed condition \citep{project2017guide}
	\oo {verification definition}
\end{defn}

\begin{defn}
	By verification, we mean all activities that are undertaken to ascertain that the
	software meets its objectives \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
	 Verification is the process of evaluating a system or component to determine whether the products
	 of a given development phase satisfy the conditions imposed at the start of that phase \citep{IEEEStdGlossarySET1990}.
\end{defn}
\noindent \textbf{Proposed Definition}

Definition~\ref{Defn_Verifiability1} rephrased:
Verifiability is the extent to which a set of tests can be written and executed, to demonstrate
that the delivered system meets the specification.

\noindent \textbf{Reasoning} 

Definition is concise and measurable.  Verifiability involves solving the
equations right \citep[p.~23]{Roache1998} and the definition states that system needs to be verifiable based on the specifications..

\subsection{\notdone{Validatability} \oo{owner}}

\begin{defn}
  Validation means solving the right equations \citep[p.~23]{Roache1998}.
\end{defn}


\begin{defn}
  The assurance that a product, service, or result meets the needs of the customer and other identified
  stakeholders \citep{project2017guide}.
\end{defn}
\begin{defn}
	Software validation is the process of checking that the system conforms to its specification and
	that it meets the real needs of the users of the system \citep{sommerville}.
	
\end{defn}
\begin{defn}
	Software validation, where the software is checked to ensure that it is what the
	customer requires \citep{sommerville}.
\end{defn}
\begin{defn}
  Software validation is achieved through a series of tests that demonstrate conformity
  with requirements \citep{pressman2005software}.
\end{defn}

\begin{defn}
	Validation is concerned with establishing that the product fulfills its
	intended use \citep{van2008software}.
\end{defn}

\begin{defn} \label{Defn_Validatability}
  The process of evaluating a system or component during or at the end of the
  development process to determine whether it satisfies specified requirements
  \citep{IEEEStdGlossarySET1990}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{Defn_Validatability} rephrased:  The effort required in evaluating
a system or component during or at the end of the development process to determine
whether it satisfies specified requirements

\noindent \textbf{Reasoning}

Definition describes that system should be measurable through the development life cycle,
It is concise and can be measured.
\subsection{\notdone{Testability} \oo{owner}}

\begin{defn}
	The degree to which you can unit-test and system-test a system;
	the degree to which you can verify that the system meets its requirements \citep{mcconnell2004code}.
\end{defn}

\begin{defn}
	Code possesses the characteristic testability to the extent that it
    facilitates the establishment of verification criteria and supports
    evaluation of its performance \citep{boehm1976quantitative}
\end{defn}

\begin{defn}
	Effort required to test a program to ensure it performs
	its intended function \citep{McCallEtAl1977}.
\end{defn}

\begin{defn} \label{Defn_Testability}
	 The degree to which a system or component facilitates the establishment of
	 test criteria and the performance of tests to determine whether those
	 criteria have been met \citep{IEEEStdGlossarySET1990}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{Defn_Testability}: The degree to which a system or component
 facilitates the establishment of test criteria and the performance of tests
 to determine whether those criteria have been met.

\noindent \textbf{Reasoning}

Definition is concise and measurable

\subsection{\notdone{Reliability} \oo{owner}}

\begin{defn}
  Informally, software is reliable if the user can depend on it \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
 The capability of the software product to maintain a specified level of performance when used under specified conditions \cite{ISO9126}.
\end{defn}
\begin{defn} \label{reliabilitySelected1} It is the probability of failure-free
  operation of a computer program in a specified environment for a specified
  time \citep{musa1987software}.
\end{defn} 
    
\begin{defn}
  Code possesses the characteristic reliability to the extent that it can be
  expected to perform its intended functions satisfactorily
  \citep{boehm1976quantitative}.
\end{defn}

\begin{defn}
  Reliability expresses the ability of the software to maintain a specified
  level of fault tolerance, when used under specified condition
  \citep{singh2013different}.
\end{defn}

\begin{defn}
  Extent to which a program can be expected to perform its intended function
  with required precision \citep{McCallEtAl1977}.
\end{defn}

\begin{defn}
  Informally, the reliability of a system is the probability, over a given
  period of time, that the system will correctly deliver services as expected by
  the user \citep{sommerville}.
\end{defn}
	
\begin{defn}
  The ability of a system or component to perform its required function under
  stated conditions for a specified period of time
  \citep{IEEEComputerDictionary1991}.
\end{defn}

\begin{defn}
  The ability of a system to perform its required functions under stated
  conditions whenever required—having a long mean time between failures
  \citep{mcconnell2004code}.
\end{defn}
\begin{defn} \label{reliabilitySelected2} Reliability is concerned with measuring
	the probability of occurence of faliure - that is, the probability of the
	observable effects of errors \citep{GhezziEtAl2003}.
\end{defn}
\oo{Statistical definition from  \citep{GhezziEtAl2003} added}
  

\noindent \textbf{Proposed Definition}

Definition \ref{reliabilitySelected1} and \ref{reliabilitySelected2} rephrased:
Probability of failure-free operation of a computer program in a specified
environment for a specified time, i.e. the average time interval between two
failures also known as the mean time to failure (MTTF).

\wss{Needs to be completed.}\oo{Done}

\noindent \textbf{Reasoning}

Reliability is defined such that the measurement metrics are visible - the
specified environment and time. 

\subsection{{Robustness} \pmi{owner}}
\begin{defn}
	The degree to which a system or component can function correctly in the
	presence of invalid inputs or stressful environmental conditions
	\citep{IEEEStdGlossarySET1990}.
\end{defn}
\begin{defn}
	The quality can be further informally refined as the ability of a software to
	keep an acceptable behaviour, expressed in terms of robustness requirements,
	in
	spite of exceptional or unforeseen execution conditions (such as the
	unavailability of system resources, communication failures, invalid or
	stressful inputs, etc.) \citep{fernandez2005model}.
\end{defn}
\begin{defn} \label{RobustnessPartialDefn}
	Code possesses the characteristic of robustness to the extent that it can
	continue to perform despite some violation of the assumptions in its
	specification \citep{boehm2007software}.
\end{defn}
\begin{defn} \label{RobustnessDefnSelected}
	A program is robust if it behaves ``reasonably'', even in circumstances that
	were not anticipated in the requirements specification - for example, when it
	encounters incorrect input data or some hardware malfunction
	\citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{RobustnessPartialDefn} and Definition
\ref{RobustnessDefnSelected} rephrased: Software possesses the characteristic of
robustness if it behaves ``reasonably'' in two situations: i) when it encounters
circumstances not anticipated in the requirements specification; and ii) when
the assumptions in its requirements specification are violated.

\noindent \textbf{Reasoning}

This definition indicates that robustness is related to the quality of
correctness (both within and outside of it). 

\pmi{Still may want to refine what we mean by reasonable}

\subsection{\notdone{Performance} \pmi{owner}}

\begin{defn} \label{PerformanceDefnSelected}
	The degree to which a system or component accomplishes its designated functions
	within given constraints, such as speed, accuracy, or memory usage
	\citep{IEEEStdGlossarySET1990}.
\end{defn}
\begin{defn} \label{PerformanceDefnSelected2}
	How well or how rapidly the system must perform specific functions. Performance
	requirements encompass speed (database response times, for instance), throughput
	(transactions per second), capacity (concurrent usage loads), and timing (hard
	real-time demands) \citep{wiegers2003softreq}.
\end{defn}
\begin{defn}
	In software engineering we often equate performance with efficiency. A software system is efficient if it uses computing resources economically
	\citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

Combined definition \ref{PerformanceDefnSelected} and
\ref{PerformanceDefnSelected2}: The degree to which a system or component
accomplishes its designated functions within given constraints, such as speed
(database response times, for instance), throughput (transactions per second),
capacity (concurrent usage loads), and timing (hard real-time
demands). \wss{What is the difference between speed and timing?}

\noindent \textbf{Reasoning}

This definition offers a comprehensive list of constraints that are commonly
associated with software performance, such as speed, throughput, capacity, and
timing.

\pmi{I will check if Wiegers discusses the difference between speed and timing.}
\pmi{Wiegers did not discuss this difference.}
\pmi{Speed - change over time; timing - related to specification: when something
	should happen in relation to something else - state transitions}
\wss{If we need both speed and timing, we should define them.  We aren't
  including accuracy from the IEEE definition.  Is that on purpose?}
\pmi{We have decided not to include accuracy. SS will find difference b/w speed and timing from a colleague.}

\subsection{\notdone{Usability} \jc{owner}} 

\begin{defn}
  The extent to which a product can be used by specified users to achieve
  specified goals with effectiveness, efficiency, and satisfaction in a
  specified context of use.
\end{defn}
ISO defines usability as

Nielsen and (separately) Schneidermann have defined usability as part of
usefulness and
is composed of:
\begin{itemize}
\item Learnability: How easy is it for users to accomplish basic tasks the first
  time they encounter the design?
\item Efficiency: Once users have learned the design, how quickly can they
  perform tasks?
\item Memorability: When users return to the design after a period of not using
  it, how easily can they re-establish proficiency?
\item Errors: How many errors do users make, how severe are these errors, and
  how easily can they recover from the errors?
\item Satisfaction: How pleasant is it to use the design?
\end{itemize}
In that context, it makes sense to separate \emph{usefulness} into
\emph{usability} (purely an interface concern) and \emph{utility} (in the
economics sense of the word).

There are two ISO standards covering this, namely ISO/TR 16982:202 and ISO9241.

The Interaction Design Foundation \url{https://www.interaction-design.org/literature/topics/usability} further
lists the following desirable outcomes:

\begin{enumerate}
\item It should be easy for the user to become familiar with and competent in
  using the user interface during the first contact with the website. For
  example, if a travel agent’s website is a well-designed one, the user should
  be able to move through the sequence of actions to book a ticket quickly.
\item It should be easy for users to achieve their objective through using the
  website. If a user has the goal of booking a flight, a good design will guide
  him/her through the easiest process to purchase that ticket.
\item It should be easy to recall the user interface and how to use it on
  subsequent visits. So, a good design on the travel agent’s site means the user
  should learn from the first time and book a second ticket just as easily.
\end{enumerate}

One core reference, for definitions and metrics, is
\citet{bevan1995measuring}.

\begin{defn}
  ``The effort required to learn, operate, prepare input, and interpret output
  of a program'' \citep{McCallEtAl1977}. (As summarized in
  \citet{VanVliet2000}.)  \wss{Once we have verified McCall said this, we can
    remove the VanVliet reference.} \pmi{Yes this is almost exactly from McCall, except he did not have the word "The" at the beginning.}
\end{defn}

\begin{defn}
  ``A software is usable - or user friendly - if its human users find it easy
  to use'' \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn}
  The capability of the software to be understood, learned, used and liked by
  the user, when used under specified conditions \cite{ISO9126}.
\end{defn}
\noindent \textbf{Proposed Definition}

\wss{Still needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Maintainability} \pmi{owner}}

\begin{defn} \label{MaintainabilityDefnSelected1} 
  The ease with which a software system or component can be modified to correct
  faults, improve performance or other attributes, or adapt to a changed
  environment \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
  ISO/IEC 25010 refers to maintainability as the degree of effectiveness and
  efficiency with which a product or system can be modified by the intended
  maintainers \citep{ISO/IEC25010}.
\end{defn}

\begin{defn}
  A set of attributes that bear on the effort needed to make specified
  modifications (which may include corrections, improvements, or adaptations of
  software to environmental changes and changes in the requirements and
  functional specifications) \citep{pfleeger2006software}.
\end{defn}

\begin{defn}
  We will view maintainability as two separate qualities: repairability and
  evolvability. Software is repairable if it allows the fixing of defects; it is
  evolvable if it allows changes that enable it to satisfy new requirements
  \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn} \label{MaintainabilityDefnSelected2} 
  Code possesses the characteristic of maintainability to the extent that it
  facilitates updating to satisfy new requirements or to correct deficiencies
  \citep{boehm2007software}.
\end{defn}

\begin{defn}
  Effort required to locate and fix an error in an operational program
  \citep{McCallEtAl1977}. \wss{It looks
    like \citet{pressman2005software} was using \citet{McCallEtAl1977} for their
    definition.} \wss{PM - can you please look into whether
    \citet{pressman2005software} cite \citet{McCallEtAl1977}?  Do they give a
    reason for dropping the word operational?}  \pmi{Yes,
    \citet{pressman2005software} does cite the relevant section of the textbook
    with \citet{McCallEtAl1977}. While they do not give a reason for
    specifically dropping the word operational, they do indicate that their
    given definition ``is a very limited definition''. Perhaps their intent was
    breadth.} \wss{Peter, please verify the McCall reference definition, and
    then just cite that.  Olu has found the McCall reference, so you shouldn't
    have to search for it.  We can remove both the VanVliet and Pressman
    reference in  preference of the McCall definition.}
\pmi{I have verified the McCall definition and removed the Pressman and van Vliet references above. I will leave these comments until all similar definitions in this document have been edited.}
\end{defn}

\begin{defn}
  The capability of the software to be modified.  Modifications may include
  corrections, improvements or adaptation of the software to changes in
  environment, and in requirements and functional specifications. \cite{ISO9126}
\end{defn}

\noindent \textbf{Proposed Definition}

Combined altered Definition \ref{MaintainabilityDefnSelected1} and Definition
\ref{MaintainabilityDefnSelected2}: The effort with which a software system or
component can be modified to:


\begin{enumerate}
	\item correct faults
	\item improve performance or other
	attributes
	\item satisfy new requirements
\end{enumerate}

\noindent \textbf{Reasoning}

This definition offers a comprehensive list of potential reasons for modifying
software, such as correcting faults, improving performance or other attributes,
or satisfying new requirements.

\wss{What are the other attributes?  What is an attribute?  Is it the
	same as a quality?  We are calling performance a quality in this document.}
\pmi{The term quality attribute has come up often in the literature - qualities
	appear to be a subset of attributes. Quality attributes seem to be associated
	with non-functional requirements. The term resource attribute was encountered in
	a journal and implied an association with a functional requirement. The two
	might differ along those lines of NFR and FR.}

\pmi{I think this is done}

\subsection{{Reusability} \pmi{owner}}

\begin{defn} 
  The degree to which a software module or other work product can be used in
  more than one software system \citep{IEEEStdGlossarySET1990}.
\end{defn}
\begin{defn}
  Extent to which a program can be used in other applications - related to the packaging and scope of the functions that programs perform \citep{McCallEtAl1977}. 
\end{defn}
\begin{defn} \label{ReusabilityDefnSelected} 
  The extent to which a software component can be used with or without
  adaptation in a problem solution other than the one for which it was
  originally developed \citep{kalagiakos2003non}.
\end{defn}
\begin{defn}
  Reusability is the likelihood a segment of source code that can be used again
  to add new functionalities with slight or no modification
  \citep{sandhu2010survey}.
\end{defn}

\begin{defn}
  A product is reusable if we can ``use the product - perhaps with minor changes
  - to build another product'' \citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition}

Definition \ref{ReusabilityDefnSelected}: The extent to which a software
component can be used with or without adaptation in a problem solution other
than the one for which it was originally developed.

\noindent \textbf{Reasoning}

This definition highlights the possible but not necessary adaptation of the
software component(s) being transferred.

\subsection{{Portability} \pmi{owner}}

\begin{defn}
  The ease with which a system or component can be transferred from one hardware
  or software environment to another \citep{IEEEStdGlossarySET1990}.
\end{defn}

\begin{defn}
  An application is portable across a class of environments to the degree that
  the effort required to transport and adapt it to a new environment in the
  class is less than the effort of redevelopment \citep{mooney1990strategies}.
\end{defn}

\begin{defn} \label{PortabilityDefnSelected} Effort required to transfer a program from one hardware configuration and/or software system environment to another \citep{McCallEtAl1977}.
\end{defn}

\begin{defn}
  A set of attributes that bear on the ability of software to be transferred
  from one environment to another (including the organizational, hardware, of
  software environment) \citep{pfleeger2006software}.
\end{defn}

\begin{defn}
  Code possesses the characteristic of portability to the extent that it can be
  operated easily and well on computer configurations other than its current
  one. This implies that special function features, not easily available at
  other facilities, are not used, that standard library functions and
  subroutines are selected for universal applicability, and so on
  \citep{boehm2007software}.
\end{defn}

\begin{defn}
  Portability refers to the ability to run a system on different hardware
  platforms \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn}
  The capability of software to be transferred from one environment to another
  \cite{ISO9126}.
\end{defn}
\noindent \textbf{Proposed Definition}

Definition \ref{PortabilityDefnSelected} rephrased: Effort required to transfer
a program between system environments (including hardware and software).

\noindent \textbf{Reasoning}

This is measurable and succinct. 



\subsection{\notdone{Understandability} \jc{owner}}

Understandability is artifact-dependent. What it means for a user-interface
(graphical or otherwise) to be understandable is wildly different than what it
means for the code, and even the user documentation.

The literature here is thin and scattered.  More work will need to be done to
find something useful.

Interestingly, the business literature seems to have taken more care to define
this.  Here we encounter
\begin{quote}
  Understandability is the concept that X should be presented so that a reader
  can easily comprehend it.
\end{quote}
At least this brings in the idea that the \emph{reader} is actively involved,
and indirectly that the reader's knowledge may be relevant, as well as the
``clarity of exposition'' of X.

Section 11.2 of \citet{adams2015nonfunctional} does have a full definition.

\begin{defn}
  The effort ``to uncover the logic of the application''
  \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn}
  The capability of the software product to enable the user to understand
  whether the software is suitable, and how it can be used for particular tasks
  and conditions of use \cite{ISO9126}.
\end{defn}

\noindent \textbf{Proposed Definition}

\wss{Still needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Interoperability} \ad{owner}}

\begin{defn}
  Effort required to couple one system with another
  \citep{McCallEtAl1977}. \wss{Ao, if
    this is from McCall, we should just cite the primary source and remove the
    Van Vliet reference.} \pmi{Yes this is almost exactly from McCall, except he did not have the word "The" at the beginning.}
    \ad{Someone with access to the book added it. I found the book in the pub
    folder and fixed it.}
\end{defn}

\begin{defn}
  Interoperability is the ability of two or more systems or components to
  exchange information and to use the information that has been exchanged
  \citep{IEEEComputerDictionary1991}.
\end{defn}

\begin{defn}
  \label{InteroperabilitySelected}
  The degree to which two or more systems, products or components can exchange
  information and use the information that has been exchanged
  \citep{ISO/IEC25010}.
\end{defn}

\begin{defn}
  The ability of a system to coexist and cooperate with other systems.
  \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn}
  The capability to communicate, execute programs, and transfer data among
  various functional units in a manner that requires the user to have little or
  no knowledge of the unique characteristics of those units
  \citep{ISO/IEC/IEEE24765}.
\end{defn}

\begin{defn}
  Interoperability is a characteristic of a product or system, whose interfaces
  are completely understood, to work with other products or systems, present or
  future, in either implementation or access, without any restrictions
  \citep{AFUL2019}.
\end{defn}

\begin{defn}
  Interoperability is the ability of different information systems, devices and
  applications (‘systems’) to access, exchange, integrate and cooperatively use
  data in a coordinated manner, within and across organizational, regional and
  national boundaries, to provide timely and seamless portability of information
  and optimize the health of individuals and populations globally. Health data
  exchange architectures, application interfaces and standards enable data to be
  accessed and shared appropriately and securely across the complete spectrum of
  care, within all applicable settings and with relevant stakeholders, including
  by the individual \citep{HIMSS2019}.
	
  Four Levels of Interoperability:
  \begin{itemize}
  \item Foundational (Level 1) – establishes the inter-connectivity requirements
    needed for one system or application to securely communicate data to and
    receive data from another
		
  \item Structural (Level 2) – defines the format, syntax, and organization of
    data exchange including at the data field level for interpretation
		
  \item Semantic (Level 3) – provides for common underlying models and
    codification of the data including the use of data elements with
    standardized definitions from publicly available value sets and coding
    vocabularies, providing shared understanding and meaning to the user
		
  \item Organizational (Level 4) – includes governance, policy, social, legal
    and organizational considerations to facilitate the secure, seamless and
    timely communication and use of data both within and between organizations,
    entities and individuals. These components enable shared consent, trust and
    integrated end-user processes and workflows
  \end{itemize}
\end{defn}

\begin{defn}
  The capability of the software to interact with one or more specified systems
  \cite{ISO9126}.
\end{defn}
\noindent \textbf{Proposed Definition}

Definition \ref{InteroperabilitySelected}.

\noindent \textbf{Reasoning}

This definition is concise and also detailed enough to show the concept not only
on system, but also on products and components. It also covered the concept with
more than 2 systems.

\subsection{\notdone{Visibility/Transparency} \ad{owner}}

\begin{defn}
  \label{VisibilitySelected}
  A software development process is visible if all of its steps and its current
  status are documented clearly. Another term used to characterize this property
  is transparency \citep{ghezzi1991fundamentals}.
\end{defn}

\begin{defn}
  Visibility provides transparency into the development process. It is the
  ability to see progress at any point and determine the distance to completion
  of a goal.  Visibility provides status of not only the progress of the
  project, but the product itself \citep{GSA2019}.
\end{defn}

\begin{defn}
  Business process visibility, also called process visibility, is the ability to
  accurately and completely view the processes, transactions and other
  activities operating within an enterprise \citep{Rouse2013}.
\end{defn}

\begin{defn}
  Process transparency refers to the ability to look inside. The “look inside”
  provides an in-depth and clear visibility into the business processes and how
  these operate \citep{PRIME2019}.
\end{defn}

\begin{defn}
The degree to which something is seen by the public
\citep{CambridgeVisibility2019}.
	
The degree to which something is seen or known about
\citep{CambridgeVisibility2019}.
\end{defn}

\noindent \textbf{Proposed Definition} 

Definition \ref{VisibilitySelected} rephrased: The extent to which all of the
steps of a software development process and the current status of it are 
conveyed clearly. \wss{I wonder if rather than
  ``documented clearly'', we should be more abstract and talk about how these
  things can be easily determined.  Documentation is probably how the
  information will be conveyed, but it doesn't have to be how it is done.}

\noindent \textbf{Reasoning}

Definition \ref{VisibilitySelected} points out that documentation is the way to
improve visibility. It is rephrased because the original one might refer to
binary status - ``visible'' or ``invisible''.

\subsection{\notdone{Reproducibility} \wss{owner}}

Reproducibility is a required component of the scientific method
\citep{Davison2012}.  Although QA has, ``a bad name among creative scientists
and engineers'' \citep[p.~352]{Roache1998}, the community need to recognize that
participating in QA management also improves reproducibility.  Reproducibility,
like QA, benefits from a consistent and repeatable computing environment,
version control and separating code from configuration/parameters
\citep{Davison2012}.

Reproducibility is defined as:

\begin{defn}
  A result is said to be reproducible if another researcher can take the
  original code and input data, execute it, and re-obtain the same result (Peng,
  Dominici, and Zeger, 2006), as cited in \citet{BenureauAndRougier2017}.
\end{defn}

The related concept of replicable is defined as:

\begin{defn}
  Documentation achieves replicability if the description it provides of the
  algorithms is sufficiently precise and complete for an independent researcher
  to re-obtain the results it presents.  \citep{BenureauAndRougier2017}
\end{defn}

It would be worthwhile to look for some additional definitions.

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Productivity} \ad{owner}}

\begin{defn}
  A quality of the software production process, referring to its efficiency and
  performance \citep{ghezzi1991fundamentals}.
\end{defn}
\begin{defn}
  The best definition of the productivity of a process is
	\[\text{Productivity} = \dfrac{\text{Outputs produced by the
              process}}{\text{Inputs consumed by the process}}\]

Thus, we can improve the productivity of the software process by increasing its
outputs, decreasing its inputs, or both. However, this means that we need to
provide meaningful definitions of the inputs and outputs of the software
process. \wss{Where did this definition come from?  Is this all from Boehm?
  This is quite a long quote.  We might actually want to paraphrase.}
\ad{all from Boehm. I feel the best way is deleting everything after the 
equation}

\textbf{Defining inputs.} For the software process, providing a meaningful
definition of inputs is a nontrivial but generally workable problem. Inputs to
the software process generally comprise labor, computers, supplies, and other
support facilities and equipment. However, one has to be careful which of
various classes of items are to be counted as inputs. For example:
\begin{itemize}
\item Phases (just software development, or should we include system
engineering, soft-ware requirements analysis, installation, or post development
support?)
\item Activities (to include documentation, project management, facilities
management, conversion, training, database administration?)
\item Personnel (to include secretaries, computer operators, business managers,
contract administrators, line management?)
\item Resources (to include facilities, equipment, communications, current
versus future dollar payments?)
\end{itemize}
An organization can usually reach an agreement on which of the above are
meaningful as inputs in their organizational context. Frequently, one can use
present-value dollars as a uniform scale for various classes of resources.

\textbf{Defining outputs.} The big problem in defining software productivity is
defining outputs. Here we find a defining delivered source instructions (DSI) or
lines of code as the output of the software process is totally inadequate, and
they argue that there are a number of deficiencies in using DSI. However,
	most organizations doing practical productivity measurement still use DSI as
	their primary metric \citep{Boehm1987}. \wss{Is this a direct quote from
		\citet{Boehm1987}?  The sentences seem incomplete?}
\ad{I added some deleted parts, now it is a direct quote. After the ending of
the quote, the following 2 pages discuss the flaws of DCI and a list of
alternatives to DCI, so I ended the quote here.}
\end{defn}
\begin{defn}
	\label{ProductivitySelected1}
Productivity is the amount of output (what is produced) per unit of input used.
In general, productivity is difficult to measure because outputs and inputs are
typically quite diverse and are often themselves difficult to measure. In the
context of software, productivity measurement is usually based on a simple ratio
of product size to project effort. Thus,If we can measure the size of the
software product and the effort required to develop the product, we have:
	\begin{align}
	\text{productivity} = \text{size}/\text{effort}
	\end{align}
Equation (1) assumes that size is the output of the software production process
and effort is the input to the process. This can be contrasted with the
	viewpoint of software cost models where we use size as an independent variable
	(i.e., an input) to predict effort which is treated as an output. Equation (1)
	is simple to operationalize if we have a single dominant size measure, for
	example, product size measured in lines of code \citep{Kitchenham2004}.
\end{defn}
\begin{defn}
	\label{ProductivitySelected2}
The number of lines of new code developed per person-day (an imperfect measure
of productivity but one that could be measured consistently)
\citep{MacCormack2003}.
\end{defn}

\noindent \textbf{Proposed Definition} 

The revision of the combination of Definition \ref{ProductivitySelected1} and
Definition \ref{ProductivitySelected2}: Productivity is the
amount of output per unit of input used, which can be measured by the summation
of all output (such as the number of lines of new code, the number of pages of
new documents and the number of new test cases) produced per person-day.

\noindent \textbf{Reasoning}

It is concise and measurable. \wss{What is the output?  What is the input?  I
	think the definition needs to give more information on these.  In particular,
	the above definitions focus on code as the output, but documentation, test
	cases etc should also be part of the output.  If we are going to measure this,
	we need a better idea of what we are measuring for outputs and inputs.}
	\ad{I added another def and made it more measurable}

\subsection{\notdone{Sustainability} \wss{owner}}

One of the original definitions of sustainability (for systems, not software
specific), and still often quoted, is:

\begin{defn}
  \noindent The ability to meet the needs of the present without compromising
  the ability of future generations to meet their own needs
  \citep{Brundtland1987}.
\end{defn}

This is the definition used by \citet{IISD2019}.

To make it more useful, this definition is often split into three dimensions:
social, economic and environmental. \wss{cite UN paper [9] in
  \citet{PenzenstadlerAndHenning2013}} To this list Penzenstadler and Henning
(2013) have added technical sustainability \citep{PenzenstadlerAndHenning2013}.
Where technical sustainability for software is defined as:

\begin{defn}
  \noindent Technical sustainability has the central objective of long-time
  usage of systems and their adequate evolution with changing surrounding
  conditions and respective requirements \citep{PenzenstadlerAndHenning2013}.
\end{defn}

The fourth dimension of technical sustainability is also added by
\citep{WolframEtAl2017}.  Technical sustainability is the focus on the thesis by
\citet{Hygerth2016}.

\begin{defn}
  \noindent Sustainable development is a mindset (principles) and an
  accompanying set of practices that enable a team to achieve and maintain an
  optimal development pace indefinitely \citep{Tate2005}.
\end{defn}

Parnas discusses as software aging \citep{Parnas1994a}.

SCS specific definitions:

\begin{defn}
  The concept of sustainability is based on three pillars: the ecological, the
  economical and the social. This means that for a software to be sustainable,
  we must take all of its effects -- direct and indirect -- on the environment,
  the economy and the society into account. In addition, the entire life cycle
  of a software has to be considered: from planning and conception to
  programming, distribution, installation, usage and disposal \citep{Heine2017}.
\end{defn}

Software Sustainability Institute proposal:

\begin{defn}
Capacity of the software to endure
\end{defn}

\citet{Katz2016} builds on this definition.

\begin{defn}
  \noindent The capacity of the software to endure. In other words,
  sustainability means that the software will continue to be available in the
  future, on new platforms, meeting new needs \citep{Katz2016}.
\end{defn}

\href{https://collegeville.github.io/CW3S19/WorkshopResources/Presentations/4-5-Katz_data-driven-software-sustainability.pdf}
{Katz Presentation}

\href{https://www.software.ac.uk/blog/2019-09-12-making-open-source-research-software-visible-path-better-sustainability}
{Neil's blog}

Definition from Neil Chue Hong:
\begin{defn}
	Sustainable software is software which is:
	-- Easy to evolve and maintain
	-- Fulfils its intent over time
	-- Survives uncertainty
	-- Supports relevant concerns (Political, Economic, Social, Technical,
	Legal, Environmental) \citep{Katz2016}.
\end{defn}

\begin{defn}
Sustainability encompasses cost efficient maintainability and evolvability \citep{SehestedtEtAl2014}.
\end{defn}

\citet{SehestedtEtAl2014} goes on to say that sustainability can be observed by
evaluating the four criteria of the architectural model: completeness,
consistency, correctness and clarity.

Definitions for sustainability are often built by combining other definitions.
\href{https://collegeville.github.io/CW3S19/WorkshopResources/Presentations/1-4-2019CollegevilleWorkshopWillenbring.pdf}
{Willenbring.pdf}
lists sustainability factors: extensible, interoperable, maintainable, portable,
reusable, scalable and usable.  \wss{Sounds like they are listing almost all
  software qualities.  It seems that sustainability is at least in part achieved
  by having high quality software.}

From
\href{https://figshare.com/articles/Defining_Sustainability_through_Developers_Eyes_Recommendations_from_an_Interview_Study/1111925/1}
{Rosado de Souza, et al.} there are two categories of software sustainability:

\begin{description}
\item[Intrinsic] Pertaining to characteristics of the software
\item[Extrinsic] Pertaining to the software development environment
\end{description}
Find paper that combines nonfunctional qualities into sustainability.

Sounds like definition of maintainability.

Paper critical of a lack of a definition \citep{VentersEtAl2014}.

Sustainability depends on the software artifacts AND the software team AND the
development process.

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\section{Desirable Qualities of Good Specifications} \label{SecDesirableQs}

To achieve the qualities listed in Section~\ref{SecQualities}, the documentation
should achieve the qualities listed in this section.  All but the final quality
listed (abstraction), are adapted from the IEEE recommended practise for
producing good software requirements \citep{IEEE1998}.  Abstraction means only
revealing relevant details, which in a requirements document means stating what
is to be achieved, but remaining silent on how it is to be achieved.
Abstraction is an important software development principle for dealing with
complexity \citep[p.~40]{GhezziEtAl2003}.  Correctness was in the above list, so
it is not repeated here.  \citet{SmithAndKoothoor2016} present further details
on the qualities of documentation for SCS.

\subsection{\notdone{Completeness} \ad{owner}}

\begin{defn}
  \label{CompletenessSelected}
  A specification is complete to the extent that all of its parts are present
  and each part is fully developed. A software specification must exhibit
  several properties to assure its completeness \citep{Boehm1984}:
  \begin{itemize}
  \item No TBDs. TBDs are places in the specification where decisions have been
    postponed by writing "To be Determined" or "TBD."
  \item No nonexistent references. These are references in the specification to
    functions, inputs, or outputs (including databases) not defined in the
    specification.
  \item No missing specification items. These are items that should be present
    as part of the standard format of the specification, but are not present.
  \item No missing functions. These are functions that should be part of the
    software product but are not called for in the specification.
  \item No missing products. These are products that should be part of the
    delivered software but are not called for in the specification.
  \end{itemize}
\end{defn}

\begin{defn}
  Those attributes of the software that provide full implementation of the 
  functions required. \citep{McCallEtAl1977}. \wss{Ao, if this is from McCall, 
  we should just cite the primary source and remove the Van Vliet reference.} 
  \pmi{McCall's definition verbatim: Those attributes of the software that 
  provide full implementation of the functions required.} \ad{Originally added 
  by someone else so I didn't have access to the book. But now it's available 
  and I double checked, Peter got it accurately.}
\end{defn}

\begin{defn}
	An SRS is complete if, and only if, it includes the following elements:
\begin{itemize}
\item All significant requirements, whether relating to functionality,
performance, design constraints, attributes, or external interfaces. In
particular any external requirements imposed by a system specification should be
acknowledged and treated.
\item Definition of the responses of the software to all realizable classes of
input data in all realizable classes of situations. Note that it is important to
specify the responses to both valid and invalid input values.
\item Full labels and references to all figures, tables, and diagrams in the SRS
and definition of all terms and units of measure \citep{IEEE1998}.
	\end{itemize}
\end{defn}
\begin{defn}
The quality of being whole or perfect and having nothing missing.
\citep{CambridgeCompleteness2019}.
\end{defn}

\wss{Were there any other definitions of completeness?  You could add the
	definition of completeness from \citet[p.\ 5--6]{IEEE1998}.  This definition
	is for
	requirements, but maybe there is something we can generalize from the
	definition?  We could also look for definitions outside of software
	development.}
\ad{added IEEE and dictionary}
\ad{\url{https://annals-csis.org/proceedings/2016/pliks/468.pdf} has a method of
measuring completeness and consistency, but I haven't summarized any def from it
yet}

\noindent \textbf{Proposed Definition} 

The first sentence of Definition \ref{CompletenessSelected}: A specification is
complete to the extent that all of its parts are present and each part is fully
developed.

\noindent \textbf{Reasoning}

It is concise and measurable.

\subsection{\notdone{Consistency} \ad{owner}}

\begin{defn}
  \label{ConsistencySelected}
  A specification is consistent to the extent that its provisions do not
  conflict with each other or with governing specifications and
  objectives. Specifications require consistency in several ways
  \citep{Boehm1984}.
  \begin{itemize}
  \item Internal consistency. Items within the specification do not conflict
    with each other.
  \item External consistency. Items in the specification do not conflict with
    external specifications or entities.
  \item Traceability. Items in the specification have clear antecedents in
    earlier specifications or statements of system objectives.
  \end{itemize}
\end{defn}

\begin{defn}
  Consistency requires that no two or more requirements in a specification
  contradict each other. It is also often regarded as the case where words and
  terms have the same meaning throughout the requirements specifications
  (consistent use of terminology). These two views of consistency imply that
  mutually exclusive statements and clashes in terminology should be avoided
  \citep{ZOWGHI2003}.
\end{defn}
\begin{defn}
  Consistency: 1. the degree of uniformity, standardization, and freedom from
  contradiction among the documents or parts of a system or component
  2. software attributes that provide uniform design and implementation
  techniques and notations \citep{ISO/IEC/IEEE24765}.
\end{defn}

\begin{defn}
  Those attributes of the software that provide uniform design and 
  implementation techniques and notation \citep{McCallEtAl1977}.  \wss{Ao, if 
  this is from McCall, we should just cite
    the primary source and remove the Van Vliet reference.} \pmi{McCall's 
    definition verbatim: Those attributes of the software that provide uniform 
    design and implementation techniques and notation.}\ad{Originally added 
  by someone else so I didn't have access to the book. But now it's available 
  and I double checked, Peter got it accurately.}
\end{defn}

\begin{defn}
Consistency refers to internal consistency. If an SRS does not agree with some
higher-level document, such as a system requirements specification, then it is
not correct \citep{IEEE1998}.
\end{defn}
\begin{defn}
An SRS is internally consistent if, and only if, no subset of individual
requirements described in it conflict. The three types of likely conflicts in an
SRS are as follows \citep{IEEE1998}:
	\begin{enumerate}[a)]
\item The specified characteristics of real-world objects may conflict. For
example,
	\begin{enumerate}[1)]
\item The format of an output report may be described in one requirement as
tabular but in another as textual.
\item One requirement may state that all lights shall be green while another may
state that all lights shall be blue.
	\end{enumerate}
\item There may be logical or temporal conflict between two specified actions.
For example,
	\begin{enumerate}[1)]
\item One requirement may specify that the program will add two inputs and
another may specify that the program will multiply them.
\item One requirement may state that “A” must always follow “B,” while another
may require that “A and B” occur simultaneously.
	\end{enumerate}
\item Two or more requirements may describe the same real-world object but use
different terms for that object. For example, a program’s request for a user
input may be called a “prompt” in one requirement and a “cue” in another. The
use of standard terminology and definitions promotes consistency.
	\end{enumerate}
\end{defn}
\begin{defn}
The state or condition of always happening or behaving in the same way
\citep{CambridgeConsistency2019}.
\end{defn}

\wss{The definition from \citet{IEEE1998} might again be useful.  We could also
  look for definitions outside of software development.  Even a dictionary
  definition could be helpful.}
\ad{added IEEE and dictionary}

\noindent \textbf{Proposed Definition} 

The first sentence of Definition \ref{ConsistencySelected}: A specification is
consistent to the extent that its provisions do not conflict with each other or
with governing specifications and objectives.

\noindent \textbf{Reasoning}

It is concise and measurable.

\subsection{\notdone{Modifiability} \jc{owner}}

Here we do seem to have a simple, if somewhat uninformative, definition:

\begin{defn}
  Modifiability is the degree of ease at which changes can be made to a system,
  and the flexibility with which the system adapts to such changes.
\end{defn}

IEEE Standard 610 seems to speak about this. (which is superseded?)

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Traceability} \jc{owner}}

Here the Wikipedia page~\url{https://en.wikipedia.org/wiki/Traceability} is
actually rather informative, especially as it also lists how this concept is
used in other domains.  A generic definition that is still quite useful is
\begin{defn}
  The capability (and implementation) of keeping track of a given set or type of
  information to a given degree, or the ability to chronologically interrelate
  uniquely identifiable entities in a way that is verifiable.
\end{defn}
By specializing the above to software artifacts, ``interrelate'' to ``why is
this here'' (for forward tracing from requirements), this does indeed give what
is meant in SE.

Various standards (DO178C, ISO 26262, and IEC61508) explicitly mention it.

24765-2017 - ISO/IEC/IEEE International Standard - Systems and software
engineering--Vocabulary
has a full definition, namely
\begin{enumerate}
\item the degree to which a relationship can be established between two or more
  products of the development process, especially products having a
  predecessor-successor or master-subordinate relationship to one another;
\item the identification and documentation of derivation paths (upward) and
  allocation or flow-down paths (downward) of work products in the work product
  hierarchy;
\item the degree to which each element in a software development product
  establishes its reason for existing; and discernible association among two or
  more logical entities, such as requirements, system elements, verifications,
  or tasks.
\end{enumerate}

\begin{defn}
  The ability to link software components to requirements
  \citep{McCallEtAl1977}. (As summarized in \citet{VanVliet2000}.)
\end{defn} \wss{Once we have verified McCall, we can remove the Van Vliet
  reference.}  \pmi{McCall's definition verbatim: Those attributes of the software that provide a thread from the requirements to the implementation with respect to the specific development and operational environment.}

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed.}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Unambiguity} \wss{owner}}

A specification is unambiguous when it has a unique interpretation.  If there is
a possibility that two readers will have two different interpretations, than the
specification is ambiguous.  \wss{When I get the Ghezzi text back from Olu, I'll
  check to see if they have anything to add to this definition.}

A Software Requirements Specification (SRS) is unambiguous if, and only if,
every requirement stated therein has only one interpretation \citep{IEEE1998}.

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed.}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Verifiability} \wss{owner}}

\begin{itemize}
	
\item Verification - Are we building the product right?  Are we implementing the
  requirements correctly (internal)
\item Validation - Are we building the right product? Are we getting the right
  requirements (external)
\item According to
	
  \href{https://en.wikipedia.org/wiki/Software_verification_and_validation}{Capability
    Maturity Model (CMM)}
  \begin{itemize}
  \item Software Verification: The process of evaluating software to determine
    whether the products of a given development phase satisfy the conditions
    imposed at the start of that phase. [IEEE-STD-610] \wss{Need a proper
      citation}
  \item Software Validation: The process of evaluating software during or at the
    end of the development process to determine whether it satisfies specified
    requirements. [IEEE-STD-610] \wss{Need a proper citation}
  \end{itemize}
\end{itemize}

``An SRS is verifiable if, and only if, every requirement stated therein is
verifiable. A requirement is verifiable if, and only if, there exists some
finite cost-effective process with which a person or machine can check that the
software product meets the requirement. In general any ambiguous requirement is
not verifiable.'' \citep{IEEE1998}

Verifiability is related to testability, which is defined by McCall et al.\ as
``The effort required to test a program to ensure that it performs its intended
function'' \citep{VanVliet2000}. \wss{Need to verify McCall reference, then
  delete VanVliet.} \pmi{McCall's definition verbatim: Effort required to test a program to insure it performs its intended function.}

\wss{When I get the Ghezzi text back from Olu, I'll check to see if they have
  anything to add to this definition.}

\begin{defn}
  A software system is verifiable if its properties can be verified easily
  \citep{ghezzi1991fundamentals}.
\end{defn}

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\subsection{\notdone{Abstract} \wss{owner}}

\begin{defn}
  Documented requirements are said to be abstract if they state what the
  software must do and the properties it must possess, but do not speak about
  how these are to be achieved \citep{GhezziEtAl2003}.
\end{defn}

\begin{defn}
  ``An abstraction for a software artifact is a succinct description that
  suppresses the details that are unimportant to a software developer and
  emphasizes the information that is important.'' \citep{Krueger1992}
\end{defn}

\begin{defn}
  ``Abstraction means that we concentrate on the essential features and ignore,
  abstract from, details that are not relevant at the level we are currently
  working.''  \citep[p.\ 296]{VanVliet2000}
\end{defn}

\begin{defn}
  ``Abstraction in mathematics is the process of extracting the underlying
  essence of a mathematical concept, removing any dependence on real world
  objects with which it might originally have been connected, and generalizing
  it so that it has wider applications or matching among other abstract
  descriptions of equivalent phenomena.''
  \href{https://en.wikipedia.org/wiki/Abstraction_(mathematics)} {Wikipedia
    Definition}
\end{defn}

Abstraction is related to reusability (and other qualities).

\wss{When I get the Ghezzi text back from Olu, I'll check to see if they have
  anything to add to this definition.}

\noindent \textbf{Proposed Definition} 

\wss{Needs to be completed}

\noindent \textbf{Reasoning}

\wss{Needs to be completed}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../CommonFiles/ResearchProposal}

\end{document}