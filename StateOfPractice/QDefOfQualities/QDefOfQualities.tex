\documentclass[letterpaper,cleveref]{lipics-v2019}

\usepackage[round]{natbib}
\usepackage{booktabs}
\usepackage{amsmath,amsthm}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links (change box color with linkbordercolor)
    citecolor=blue,       % color of links to bibliography
    filecolor=magenta,   % color of file links
    urlcolor=cyan           % color of external links
}

%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}} %Spencer Smith
\newcommand{\jc}[1]{\authornote{red}{JC}{#1}} %Jacques Carette
\newcommand{\oo}[1]{\authornote{magenta}{OO}{#1}} %Olu Owojaiye
\newcommand{\pmi}[1]{\authornote{green}{PM}{#1}} %Peter Michalski
\newcommand{\ad}[1]{\authornote{cyan}{AD}{#1}} %Ao Dong

%\oddsidemargin 0mm
%\evensidemargin 0mm
%\textwidth 160mm
%\textheight 200mm

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\title{Quality Definitions of Qualities} 
\author{Spencer Smith}{McMaster University, Canada}{smiths@mcmaster.ca}{}{}
\author{Jacques Carette}{McMaster University, Canada}{carette@mcmaster.ca}{}{}
\author{Olu Owojaiye}{McMaster University, Canada}{owojaiyo@mcmaster.ca}{}{}
\author{Peter Michalski}{McMaster University, Canada}{}{}{}
\author{Ao Dong}{McMaster University, Canada}{}{}{}

\authorrunning{Smith et al.}
\Copyright{Spencer Smith and Jacques Carette and Olu Owojaiye and Peter Michalski and Ao Dong}

\date{\today}
	
\hideLIPIcs
\nolinenumbers

\begin{document}
\maketitle

\begin{abstract}
  ...
\end{abstract}

\tableofcontents

\section{Introduction} \label{SecIntroduction}

Purpose and scope of the document.  \wss{Needs to be filled in.  Should
  reference the overal research proposal, and the ``state of the practice''
  exercise in particular.}

The presentation is divided into two main sections: i) qualities that apply to software products,
software artifacts and software development processes, and ii) qualities that
are considered important for good specifications.  The specification could be a
specification of requirements, design or a test plan.  

\section{Qualities of Software Products, Artifacts and
  Processes} \label{SecQualities}

To assess the current state of software development, and to understand how
future changes impact software development, we need a clear definition of what
we mean by quality.  The concept of quality is decomposed into a set of separate
components that together make up ``quality''. Unfortunately, these are
called \emph{qualities}. These are associated to the software product,
the software artifacts (documentation, test cases, etc) and to the software
development process itself, and combinations thereof.

Our analysis is centred around a set of software qualities.  Quality is not
considered as a single measure, but a collection of different qualities, often
called ``ilities.''  These qualities highlight the desirable nonfunctional
properties for software artifacts, which include both documentation and
code. Some qualities, such as visibility and productivity, apply to the process
used for developing the software. The following list of qualities is based on
\cite{GhezziEtAl2003}. To the list from \cite{GhezziEtAl2003}, we have added
three qualities important for SC: installability, reproducibility and
sustainability.

\subsection{Installability}
\begin{itemize}
    \item{Definition 1:} A measure of the ease of installation.\\
	\item{Definition 2:} Installability is related to the amount of human effort required to install a software in a designated environment \cite{berander2005software}. \\
	\item{Definition 3:} ``The capability of a software product to be installed in a specified environment'' \cite{berander2005software}.\\
	\item{Definition 4:}  ``The efficacy of the installation, uninstallation or reinstallation process of a software product in a specified enviroment'' (\cite{iso201017043})\\
	\item {\textbf{Proposed definition}:} (Definition 2)
\end{itemize}

\subsection{Correctness}

\begin{defn}
  The degree to which a software's specification is satisfied
  \citep{berander2005software}.
\end{defn}

\begin{defn} \label{CorrectDefnSelected}
  A software is correct if it functions according to its specified functional
  and non-functional specification \cite{GhezziEtAl2003}.
\end{defn}

\begin{defn}
  According to \citet{wilson2009quality}, ``the degree to which a system is free
  from defects in its specification, design, and implementation, is its
  correctness.''
\end{defn}

\begin{defn}
  ``The ability of software products to perform their exact tasks, as defined by
  their specification'' \citep{meyer1988object}.
\end{defn}

\begin{defn}
  The extent to which a program satisfies its specifications and fulfills the
  user's mission objectives \citep{McCallEtAl1977}.
\end{defn}

\noindent \textbf{Proposed definition}: Definition~\ref{CorrectDefnSelected}
	
\subsubsection{Discussion}
There is no direct tool or
method for measuring correctness. One way of building confidence in correctness
is by reviewing to ensure that each requirement stated is one that the
stakeholders and experts desire.  By maintaining traceability, consistency and
unambiguity, we can reduce the occurrence of errors and make the goal of
reviewing for correctness easier.\\
 The quality of a software's operation is dependent on the degree of correctness \cite{berander2005software}. Correctness and reliability are said to have dependencies, such that if a system exhibits a high degree of correctness then it tends to be reliable (\cite{GhezziEtAl2003}).

\subsection{Verifiability}
\begin{itemize}
	\item{Definition 1:} A software is verifiable if its properties can be verified (\cite{GhezziEtAl2003}).\\
	\item{Definition 2:} Attributes of software that relate to the effort needed for validating the modified software (\cite{berander2005software}).\\
	\item{Definition 3:}) The degree to which a system or component facilitates the establishment of test criteria and the performance of tests to determine whether those criteria have been met (\cite{IEEEStdGlossarySET1990}).\\
	\item{Definition 4:}  The degree to which a requirement is stated in terms that permit establishment of test criteria and performance (\cite{IEEEStdGlossarySET1990}).\\
	\item{Definition 5:} Ease of performing testing on a software product or system (\cite{IEEEStdGlossarySET1990}).\\
	\item{\textbf{Proposed definition}:} Combo of definitions 4 and 5 ?\\
\end{itemize}
\subsubsection{Discussion}
Verifiability involves ``solving the equations right''~\cite[p.~23]{Roache1998};
it benefits from rational documentation that systematically shows, with explicit
traceability, how the governing equations are transformed into code.
\oo{Verifiability is sometimes referred to as testability, so I culled some testability definitions here}\\
\subsection{Validatability}
\begin{itemize}
\item{Definition 1:} Validatability of a software is the degree of ease in validating(checking) that software meets user needs.\\
\item{Definition 2:} Validatability means ``solving the right equations''~\cite[p.~23]{Roache1998}.
\oo{question about this definition}\\
\item{Definition 3:} The degree of ease of evaluating software products or system to determine whether it satisfies specified business requirements. \url{http://softwaretestingfundamentals.com/verification-vs-validation/}\\
\oo{Here I tweaked the meaning of validation to suit validatability}\\
\oo{Only a few resource on validatability}\\
\item{\textbf{Proposed definition}:} Definition 3
\end{itemize}
\subsubsection{Discussion}
Validatability is improved by a rational process via clear documentation of the
theory and assumptions, along with an explicit statement of the systematic steps
required for experimental validation.

\subsection{Reliability}
\begin{itemize}
	\item{Definition 1:} The probability that the software will operate as expected over a specified time interval (\cite{GhezziEtAl2003}).\\
	\item{Definition 2:} A set of attributes that relate to the capability of software to maintain its level of performance under stated conditions for a stated period of time (\cite{berander2005software}).\\
	\item{Definition 3:} “The capability of the software product to maintain a specified level of performance when used under specified conditions (\cite{international2001iso}).\\
	\item{Definition 4:} Code possesses the characteristic reliability to the extent that it can be expected to perform its intended functions satisfactorily (\cite{boehm2007software})\\
	\item{Definition 5:} A concern encompassing correctness and robustness (\cite{meyer1988object}).\\
	\item{Proposed definition}\\
\end{itemize}

\subsubsection{Discussion}
Reliability is a critical quality for scientific software, since the results of
computations are meaningless, if they are not dependable.  Reliability is
closely tied to verifiability, since the key quality to verify is reliability,
while the act of verification itself improves reliability.\\
Reliability models can be used to predict reliability of a software product. For example measuring Mean Time to Fail (MTTF) can be a good measure of reliability \cite{berander2005software}

\subsection{Robustness}
\begin{defn}
The degree to which a system or component can function correctly in the presence of invalid inputs or stressful environmental conditions \cite{IEEEStdGlossarySET1990}.\\
\end{defn}
\begin{defn}
The quality can be further informally refined as the ability of a software to keep an acceptable behavior, expressed in terms of robustness requirements, in spite of exceptional or unforeseen execution conditions (such as the unavailability of system resources, communication failures, invalid or stressful inputs, etc.) \cite{fernandez2005model}.\\
\end{defn}
\begin{defn}
Code possesses the characteristic of robustness to the extent that it can continue to perform despite some violation of the assumptions in its specification \cite{boehm2007software}.
\end{defn}
\begin{defn}
A program is robust if it behaves "reasonably", even in circumstances that were not anticipated in the requirements specification - for example, when it encounters incorrect input data or some hardware malfunction \cite{ghezzi1991fundamentals}\\
\end{defn}

\textbf{Chosen definition:}\\
Combined Boehm and GhezziL\\
Software possesses the characteristic of robustness if it fulfills its requirements correctly or behaves reasonably in circumstances not anticipated in the requirements specification.\\



\subsection{Performance}
\begin{defn}
The degree to which a system or component accomplishes its designated functions within given constraints, such as speed, accuracy, or memory usage \cite{IEEEStdGlossarySET1990}.\\
\end{defn}
\begin{defn}
How well or how rapidly the system must perform specific functions. Performance requirements encompass speed (database response times, for instance), throughput ( transactions per second), capacity (con-current usage loads), and timing (hard real-time demands) \cite{wiegers2003softreq}.
\end{defn}
\begin{defn}
In software engineering we often equate performance with efficiency. A software system is efficient if it uses computing resources economically \cite{ghezzi1991fundamentals}\\
\end{defn}

\textbf{Chosen definition:}\\
How well or how rapidly the system must perform specific functions. Performance requirements encompass speed (database response times, for instance), throughput ( transactions per second), capacity (con-current usage loads), and timing (hard real-time demands) \cite{wiegers2003softreq}.\\


\subsection{Usability}

ISO defines usability as
\begin{quote}
The extent to which a product can be used by specified users to achieve
specified goals with effectiveness, efficiency, and satisfaction in a specified
context of use.
\end{quote}

Nielsen and (separately) Schneidermann have defined usability as part of usefulness and
is composed of
\begin{itemize}
\item Learnability: How easy is it for users to accomplish basic tasks the
  first time they encounter the design?
\item Efficiency: Once users have learned the design, how quickly can they perform tasks?
\item Memorability: When users return to the design after a period of not using
  it, how easily can they re-establish proficiency?
\item Errors: How many errors do users make, how severe are these errors, and
  how easily can they recover from the errors?
\item Satisfaction: How pleasant is it to use the design?
\end{itemize}
In that context, it makes sense to separate \emph{usefulness} into
\emph{usability} (purely an interface concern) and \emph{utility} (in the economics
sense of the word).

There are two ISO standards covering this, namely ISO/TR 16982:202 and ISO 9241. 

The Interaction Design Foundation~\url{https://www.interaction-design.org/literature/topics/usability}
further lists the following desirable outcomes:
\begin{enumerate}
\item It should be easy for the user to become familiar with and competent in using
the user interface during the first contact with the website. For example, if a
travel agent’s website is a well-designed one, the user should be able to move
through the sequence of actions to book a ticket quickly.
\item It should be easy for users to achieve their objective through using the
website. If a user has the goal of booking a flight, a good design will guide
him/her through the easiest process to purchase that ticket.
\item It should be easy to recall the user interface and how to use it on
subsequent visits. So, a good design on the travel agent’s site means the user
should learn from the first time and book a second ticket just as easily.
\end{enumerate}

One core reference, for definitions and metrics, is Bevan~\cite{bevan1995measuring}.

\subsection{Maintainability}
\begin{defn}
The ease with which a software system or component can be modified to correct faults, improve performance or other attributes, or adapt to a changed environment \cite{IEEEStdGlossarySET1990}. 
\end{defn}\
\begin{defn}
ISO/IEC 25010 refers to maintainability as the degree of effectiveness and efficiency with which a product or system can be modified by the intended maintainers \cite{ISO/IEC25010}.
\end{defn}
\begin{defn}
Effort required to locate and fix an error in a program
\cite{pressman2005software}.\\
\end{defn}
\begin{defn}
A set of attributes that bear on the effort needed to make specified modifications (which may include corrections, improvements, or adaptations of software to environmental changes and changes in the requirements and functional specifications)\cite{pfleeger2006software}.
\end{defn}
\begin{defn}
We will view maintainability as two separate qualities: repairability and evolvability. Software is repairable if it allows the fixing of defects; it is evolvable if it allows changes that enable it to satisfy new requirements \cite{ghezzi1991fundamentals}.
\end{defn}
\begin{defn}
Code possesses the characteristic of maintainability to the extent that it facilitates updating to satisfy new requirements or to correct deficiencies \cite{boehm2007software}.
\end{defn}

\textbf{Chosen definition:}\\
Combined IEEE and Boehm:\\
The ease with which a software system or component can be modified to correct faults, improve performance or other attributes, or satisfy new requirements.\\



\subsection{Reusability}
\begin{defn}
The degree to which a software module or other work product can be used in more than one software system \cite{IEEEStdGlossarySET1990}. \\
\end{defn}
\begin{defn}
Extent to which a program [or parts of a program] can be reused in other applications - related to the packaging and scope of the functions that the program performs \cite{pressman2005software}.\\
\end{defn}

\textbf{Chosen definition:}\\
New definition:\\ The degree to which a software product can be modularized for easy transferal into other systems.\\




\subsection{Portability}
\begin{defn}
The ease with which a system or component can be transferred from one hardware or software environment to another \cite{IEEEStdGlossarySET1990}. \\
\end{defn}
\begin{defn}
An application is portable across a class of environments to the degree that the effort required to transport and adapt it to a new environment in the class is less than the effort of redevelopment \cite{mooney1990strategies}.\\
\end{defn}
\begin{defn}
Effort required to transfer the program from one hardware and/or software system environment to another \cite{pressman2005software}.\\
\end{defn}
\begin{defn}
A set of attributes that bear on the ability of software to be transferred from one environment to another (including the organizational, hardware, of software environment)\cite{pfleeger2006software}.\\
\end{defn}
\begin{defn}
Code possesses the characteristic of portability to the extent that it can be operated easily and well on computer configurations other than its current one. This implies that special function features, not easily available at other facilities, are not used, that standard library functions and subroutines are selected for universal applicability, and so on \cite{boehm2007software}.
\end{defn}
\begin{defn}
Portability refers to the ability to run a system on different hardware platforms \cite{ghezzi1991fundamentals}.
\end{defn}
\textbf{Chosen definition:}\\ Effort required to transfer the program from one hardware and/or software system environment to another \cite{pressman2005software}.\\
Rephrased: Effort required to transfer a program between system environments.\\
Alternatively: Ease with which a program can be transferred between system environments.
How is effort defined here? metric? measure?\\



 

\subsection{Understandability}

Understandability is artifact-dependent. What it means for a user-interface (graphical
or otherwise) to be understandable is wildly different than what it means for the code,
and even the user documentation.

The literature here is thin and scattered.  More work will need to be done to find
something useful.

Interestingly, the business literature seems to have taken more care to define this.
Here we encounter
\begin{quote}
Understandability is the concept that X should be presented
so that a reader can easily comprehend it.
\end{quote}
At least this brings in the idea that the \emph{reader} is actively involved, and
indirectly that the reader's knowledge may be relevant, as well as the
``clarity of exposition'' of X.

Section 11.2 of~\cite{adams2015nonfunctional} does have a full definition.

\subsection{Interoperability}

\begin{enumerate}[(1).]
    \item Interoperability is the ability of two or more systems or components to exchange information and to use the information that has been exchanged~\cite{IEEE1991}.
	\item The degree to which two or more systems, products or components can exchange information and use the information that has been exchanged~\cite{ISO/IEC25010}.
	\item The capability to communicate, execute programs, and transfer data among various functional units in a manner that requires the user to have little or no knowledge of the unique characteristics of those units~\cite{ISO/IEC/IEEE24765}.
	\item Interoperability is a characteristic of a product or system, whose interfaces are completely understood, to work with other products or systems, present or future, in either implementation or access, without any restrictions~\cite{AFUL}.
    \item \ad{My recommendation is the following one}\\
    Interoperability is the ability of different information systems, devices and applications (‘systems’) to access, exchange, integrate and cooperatively use data in a coordinated manner, within and across organizational, regional and national boundaries, to provide timely and seamless portability of information~\cite{HIMSS}.
        
    Four Levels of Interoperability:
    \begin{itemize}
        \item Foundational (Level 1) – establishes the inter-connectivity requirements needed for one system or application to securely communicate data to and receive data from another

        \item Structural (Level 2) – defines the format, syntax, and organization of data exchange including at the data field level for interpretation

        \item Semantic (Level 3) – provides for common underlying models and codification of the data including the use of data elements with standardized definitions from publicly available value sets and coding vocabularies, providing shared understanding and meaning to the user

        \item “New” Organizational (Level 4) – includes governance, policy, social, legal and organizational considerations to facilitate the secure, seamless and timely communication and use of data both within and between organizations, entities and individuals. These components enable shared consent, trust and integrated end-user processes and workflows
    \end{itemize}
\end{enumerate}

\subsection{Visibility/Transparency}
    \ad{I found little contents related to visibility or transparency. The following definition is the only one I could find, but may be irrelevant to this project.}
    \begin{quotation}
        1. the degree to which a transaction can access object state concurrently with other transactions. 2. the specification, for a property, of "who can see it?"~\cite{ISO/IEC/IEEE24765}
    \end{quotation}
      
\subsection{Reproducibility}

Reproducibility is a required component of the scientific
method~\cite{Davison2012}.  Although QA has, ``a bad name among creative
scientists and engineers''~\cite[p.~352]{Roache1998}, the community need to
recognize that participating in QA management also improves reproducibility.
Reproducibility, like QA, benefits from a consistent and repeatable computing
environment, version control and separating code from
configuration/parameters~\cite{Davison2012}.

Reproducibility is defined as:

\begin{defn}
A result is said to be reproducible if another researcher can take the original
code and input data, execute it, and re-obtain the same result (Peng, Dominici,
and Zeger, 2006), as cited in \citet{BenureauAndRougier2017}.
\end{defn}

The related concept of replicable is defined as:

\begin{defn}
Documentation achieves replicability if the description it provides of the
algorithms is sufficiently precise and complete for an independent researcher to
re-obtain the results it presents.  \citep{BenureauAndRougier2017}
\end{defn}

It would be worthwhile to look for some additional definitions.

\subsection{Productivity}
\begin{enumerate}[(1).]
    \item
    
    The best definition of the productivity of a process is
    \[\text{Productivity} = \dfrac{\text{Outputs produced by the
          process}}{\text{Inputs consumed by the process}}\]
    Defining inputs. For the software process, providing a meaningful definition
    of inputs is a nontrivial but generally workable problem. Inputs to the software process generally comprise labor, computers, supplies, and other support facilities and equipment. Defining outputs. The big problem in
    defining software productivity is defining outputs. Here we find a
    paradox. Most sources say that defining delivered source instructions (DSI)
    or lines of code as the output of the software process is totally
    inadequate, and they argue that there are a number of deficiencies in using
    DSI. However, most organizations doing practical productivity measurement
    still use DSI as their primary metric~\cite{Boehm1987}.

    \item \ad{My recommendation is the following one}\\
    Productivity is the amount of output (what is produced) per unit of input used.If we can measure the size of the software product and the effort required to develop the product, we have:
    \begin{align}
        \text{productivity} = \text{size}/\text{effort}
    \end{align}
    Equation (1) assumes that size is the output of the software production
    process and effort is the input to the process. This can be contrasted with
    the viewpoint of software cost models where we use size as an independent
    variable (i.e., an input) to predict effort which is treated as an
    output. Equation (1) is simple to operationalize if we have a single
    dominant size measure, for example, product size measured in lines of
    code~\cite{Kitchenham2004}.
\end{enumerate}

\subsection{Sustainability}

One of the original definitions of sustainability (for systems, not software
specific), and still often quoted, is:

\begin{defn}
\noindent The ability to meet the needs of the present without compromising the ability of
future generations to meet their own needs \cite{Brundtland1987}.
\end{defn}

This is the definition used by~\cite{IISD2019}.

To make it more useful, this definition is often split into three dimensions:
social, economic and environmental. \wss{cite UN paper [9] in
  \cite{PenzenstadlerAndHenning2013}}  To this list Penzenstadler and Henning
(2013) have added technical sustainability \cite{PenzenstadlerAndHenning2013}.
Where technical sustainability for software is defined as:

\begin{defn}
\noindent Technical sustainability has the central objective of long-time
usage of systems and their adequate evolution with changing surrounding
conditions and respective requirements \cite{PenzenstadlerAndHenning2013}.
\end{defn}

The fourth dimension of technical sustainability is also added
by~\cite{WolframEtAl2017}.  Technical sustainability is the focus on the thesis
by~\cite{Hygerth2016}.

\begin{defn}
  \noindent Sustainable development is a mindset (principles) and an
  accompanying set of practices that enable a team to achieve and maintain an
  optimal development pace indefinitely~\cite{Tate2005}.
\end{defn}

Parnas discusses as software aging~\cite{Parnas1994a}.

SCS specific definitions:

\begin{defn}
  The concept of sustainability is based on three pillars: the
  ecological, the economical and the social. This means that for a software to
  be sustainable, we must take all of its effects -- direct and indirect -- on
  the environment, the economy and the society into account. In addition, the
  entire life cycle of a software has to be considered: from planning and
  conception to programming, distribution, installation, usage and
  disposal~\cite{Heine2017}.
\end{defn}

\begin{defn}
  \noindent The capacity of the software to endure. In other words,
  sustainability means that the software will continue to be available in the
  future, on new platforms, meeting new needs~\cite{Katz2016}.
\end{defn}

Definition from Neil Chue Hong:
\begin{defn}
Sustainable software is software which is:
-- Easy to evolve and maintain
-- Fulfils its intent over time
-- Survives uncertainty
-- Supports relevant concerns (Political, Economic, Social, Technical,
Legal, Environmental)~\cite{Katz2016}.
\end{defn}

Paper critical of a lack of a definition~\cite{VentersEtAl2014}.

Sounds like definition of maintainability.

Find paper that combines nonfunctional qualities into sustainability.

Sustainability depends on the software artifacts AND the software team AND the
development process.

\section{Desirable Qualities of Good Specifications} \label{SecDesirableQs}

To achieve the qualities listed in Section~\ref{SecQualities}, the documentation
should achieve the qualities listed in this section.  All but the final quality
listed (abstraction), are adapted from the IEEE recommended practise for
producing good software requirements~\cite{IEEE1998}.  Abstraction means only
revealing relevant details, which in a requirements document means stating what
is to be achieved, but remaining silent on how it is to be achieved.
Abstraction is an important software development principle for dealing with
complexity~\cite[p.~40]{GhezziEtAl2003}.  Correctness was in the above list, so
it is not repeated here.  \citet{SmithAndKoothoor2016} present further details
on the qualities of documentation for SCS.

\subsection{Completeness}
\begin{enumerate}[(1).]
    \item
    \ad{This part was here before my modification}\\
    Documentation is said to be complete when all the requirements of the software are detailed. That is, each goal, functionality, attribute, design constraint, value, data, model, symbol, term (with its unit of measurement if applicable), abbreviation, acronym, assumption and performance requirement of the software is defined.  The software's response to all classes of inputs, both valid and invalid and for both desired and undesired events, also needs to be specified.

    \item
    \ad{My recommendation is the following one}\\
    A specification is complete to the extent that all of its parts are present and each part is fully developed. A software specification must exhibit several properties to assure its completeness:
    \begin{itemize}
        \item No TBDs. TBDs are places in the specification where decisions have been postponed by writing "To be Determined" or "TBD."
        \item No nonexistent references. These are references in the specification to functions, inputs, or outputs (including databases) not defined in the specification.
        \item No missing specification items. These are items that should be present as part of the standard format of the specification, but are not present.
        \item No missing functions. These are functions that should be part of the software product but are not called for in the specification.
        \item No missing products. These are products that should be part of the delivered software but are not called for in the specification.~\cite{Boehm1984}.
    \end{itemize}
\end{enumerate}

\subsection{Consistency}
\begin{enumerate}[(1).]
    \item
    \ad{This part was here before my modification}\\
    Documentation is said to be consistent when no subset of individual statements are in conflict with each other. That is, a specification of an item made at one place in the document should not contradict the specification of the same item at another location.

    \item    A specification is consistent to the extent that its provisions do not conflict with each other or with governing specifications and objectives. Specifications require consistency in several ways.
    \begin{itemize}
        \item Internal consistency. Items within the specification do not conflict with each other.
        \item External consistency. Items in the specification do not conflict with external specifications or entities.
        \item Traceability. Items in the specification have clear antecedents in earlier specifications or statements of system objectives~\cite{Boehm1984}.
    \end{itemize}
    \item Consistency requires that no two or more requirements in a specification contradict each other. It is also often regarded as the case where words and terms have the same meaning throughout the requirements specifications (consistent use of terminology). These two views of consistency imply that mutually exclusive statements and clashes in terminology should be avoided~\cite{ZOWGHI2003}.
    \item Consistency: 1. the degree of uniformity, standardization, and freedom from contradiction among the documents or parts of a system or component 2. software attributes that provide uniform design and implementation techniques and notations~\cite{ISO/IEC/IEEE24765}
\end{enumerate}

\subsection{Modifiability}

Here we do seem to have a simple, if somewhat uninformative, definition:

\begin{defn}
Modifiability is the degree of ease at which changes can be made to a system,
and the flexibility with which the system adapts to such changes.
\end{defn}

IEEE Standard 610 seems to speak about this. (which is superceded?)

\subsection{Traceability}

Here the Wikipedia page~\url{https://en.wikipedia.org/wiki/Traceability} is actually
rather informative, especially as it also lists how this concept is used in other domains.
A generic definition that is still quite useful is
\begin{defn}
The capability (and implementation) of keeping track of a given set or type of
information to a given degree, or the ability to chronologically interrelate
uniquely identifiable entities in a way that is verifiable.
\end{defn}
By specializing the above to software artifacts, ``interrelate'' to 
``why is this here'' (for forward tracing from requirements), this does
indeed give what is meant in SE.

Various standards (DO178C, ISO 26262, and IEC61508) explicitly mention it.

24765-2017 - ISO/IEC/IEEE International Standard - Systems and software engineering--Vocabulary
has a full definition, namely
\begin{enumerate}
\item the degree to which a relationship can be established between two or more
products of the development process, especially products having a
predecessor-successor or master-subordinate relationship to one another;
\item
the identification and documentation of derivation paths (upward) and
allocation or flowdown paths (downward) of work products in the work product
hierarchy;
\item the degree to which each element in a software development
product establishes its reason for existing; and discernible association
among two or more logical entities, such as requirements, system elements,
verifications, or tasks.
\end{enumerate}

\subsection{Unambiguity}

A specification is unambiguous when it has a unique interpretation.  If there is
a possibility that two readers will have two different interpretations, than the
specification is ambiguous.  \wss{When I get the Ghezzi text back from Olu, I'll
  check to see if they have anything to add to this definition.}

A Software Requirements Specification (SRS) is unambiguous if, and only if,
every requirement stated therein has only one interpretation \citep{IEEE1998}.

\subsection{Verifiability}

\begin{itemize}

\item Verification - Are we building the product right?  Are we implementing the
  requirements correctly (internal)
\item Validation - Are we building the right product? Are we getting the right
  requirements (external)
\item According to
  \href{https://en.wikipedia.org/wiki/Software_verification_and_validation}{Capability
    Maturity Model (CMM)}
\begin{itemize}
\item 
    Software Verification: The process of evaluating software to determine
    whether the products of a given development phase satisfy the conditions
    imposed at the start of that phase. [IEEE-STD-610]
  \item Software Validation: The process of evaluating software during or at the
    end of the development process to determine whether it satisfies specified
    requirements. [IEEE-STD-610] 
\end{itemize}
\end{itemize}

``An SRS is verifiable if, and only if, every requirement stated therein is
verifiable. A requirement is verifiable if, and only if, there exists some
finite cost-effective process with which a person or machine can check that the
software product meets the requirement. In general any ambiguous requirement is
not verifiable.'' \citep{IEEE1998}

Verifiability is related to testability, which is defined by McCall et al.\ as
``The effort required to test a program to ensure that it performs its intended
function'' \cite{VanVliet2000}.  

\wss{When I get the Ghezzi text back from Olu,
  I'll check to see if they have anything to add to this definition.}

\subsection{Abstract}

\begin{defn}
Documented requirements are said to be abstract if they state what the software
must do and the properties it must possess, but do not speak about how these are
to be achieved \citep{GhezziEtAl2003}.  
\end{defn}

\begin{defn}
``An abstraction for a software artifact is a succinct description that suppresses
the details that are unimportant to a software developer and emphasizes the
information that is important.'' \cite{Krueger1992}
\end{defn}

\begin{defn}
``Abstraction means that we concentrate on the essential features and ignore,
abstract from, details that are not relevant at the level we are currently
working.''  \cite[p.\ 296]{VanVliet2000}
\end{defn}

\begin{defn}
``Abstraction in mathematics is the process of extracting the underlying essence
of a mathematical concept, removing any dependence on real world objects with
which it might originally have been connected, and generalizing it so that it
has wider applications or matching among other abstract descriptions of
equivalent phenomena.''
\href{https://en.wikipedia.org/wiki/Abstraction_(mathematics)} {Wikipedia
  Definition}
\end{defn}

Abstraction is related to reusability (and other qualities).

\wss{When I get the Ghezzi text back from Olu, I'll check to see if they have
  anything to add to this definition.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../CommonFiles/ResearchProposal}

\end{document}
