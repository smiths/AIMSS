\documentclass[letterpaper,cleveref]{lipics-v2019}

\usepackage[round]{natbib}
\usepackage{booktabs}
\usepackage{amsmath,amsthm}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=red,          % color of internal links (change box color with linkbordercolor)
    citecolor=blue,       % color of links to bibliography
    filecolor=magenta,   % color of file links
    urlcolor=cyan           % color of external links
}

%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}} %Spencer Smith
\newcommand{\jc}[1]{\authornote{red}{JC}{#1}} %Jacques Carette
\newcommand{\oo}[1]{\authornote{magenta}{OO}{#1}} %Olu Owojaiye
\newcommand{\pmi}[1]{\authornote{green}{PM}{#1}} %Peter Michalski
\newcommand{\ad}[1]{\authornote{cyan}{AD}{#1}} %Ao Dong

%\oddsidemargin 0mm
%\evensidemargin 0mm
%\textwidth 160mm
%\textheight 200mm

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\title{Quality Definitions of Qualities} 
\author{Spencer Smith}{McMaster University, Canada}{smiths@mcmaster.ca}{}{}
\author{Jacques Carette}{McMaster University, Canada}{carette@mcmaster.ca}{}{}
\author{Olu Owojaiye}{McMaster University, Canada}{}{}{}
\author{Peter Michalski}{McMaster University, Canada}{}{}{}
\author{Ao Dong}{McMaster University, Canada}{}{}{}

\authorrunning{Smith et al.}
\Copyright{Spencer Smith and Jacques Carette and Olu Owojaiye and Peter Michalski and Ao Dong}

\date{\today}
	
\hideLIPIcs
\nolinenumbers

\begin{document}
\maketitle

\begin{abstract}
  ...
\end{abstract}

\tableofcontents

\section{Introduction} \label{SecIntroduction}

Purpose and scope of the document.  \wss{Needs to be filled in.  Should
  reference the overal research proposal, and the ``state of the practice''
  exercise in particular.}

The presentation is divided into two main sections: i) qualities that apply to software products,
software artifacts and software development processes, and ii) qualities that
are considered important for good specifications.  The specification could be a
specification of requirements, design or a test plan.  

\section{Qualities of Software Products, Artifacts and
  Processes} \label{SecQualities}

To assess the current state of software development, and to understand how
future changes impact software development, we need a clear definition of what
we mean by quality.  The concept of quality is decomposed into a set of separate
components that together make up ``quality''. Unfortunately, these are
called \emph{qualities}. These are associated to the software product,
the software artifacts (documentation, test cases, etc) and to the software
development process itself, and combinations thereof.

Our analysis is centred around a set of software qualities.  Quality is not
considered as a single measure, but a collection of different qualities, often
called ``ilities.''  These qualities highlight the desirable nonfunctional
properties for software artifacts, which include both documentation and
code. Some qualities, such as visibility and productivity, apply to the process
used for developing the software. The following list of qualities is based on
\cite{GhezziEtAl2003}. To the list from \cite{GhezziEtAl2003}, we have added
three qualities important for SC: installability, reproducibility and
sustainability.

\subsection{Installability}

A measure of the ease of installation.\\
Installability is related to the effort required to install a software in a specified environment. In other words, its capability to be installed in a specified environment.


\subsection{Correctness}

Software is correct if it matches its specification.  There is no direct tool or
method for measuring correctness. One way of building confidence in correctness
is by reviewing to ensure that each requirement stated is one that the
stakeholders and experts desire.  By maintaining traceability, consistency and
unambiguity, we can reduce the occurrence of errors and make the goal of
reviewing for correctness easier.\\
 The extent to which a software's specification, design and implementation is free from errors is its correctness. The quality of a software's operation is dependent on the degree of correctness \cite{berander2005software}. Correctness and reliability are said to have dependencies, such that if a system exhibits a high degree of correctness then it tends to be reliable.

\subsection{Verifiability}

Verifiability involves ``solving the equations right''~\cite[p.~23]{Roache1998};
it benefits from rational documentation that systematically shows, with explicit
traceability, how the governing equations are transformed into code.

\subsection{Validatability}

Validatability means ``solving the right equations''~\cite[p.~23]{Roache1998}.
Validatability is improved by a rational process via clear documentation of the
theory and assumptions, along with an explicit statement of the systematic steps
required for experimental validation.

\subsection{Reliability}

Reliability is a critical quality for scientific software, since the results of
computations are meaningless, if they are not dependable.  Reliability is
closely tied to verifiability, since the key quality to verify is reliability,
while the act of verification itself improves reliability.\\
Reliability models can be used to predict reliability of a software product. For example measuring Mean Time to Fail (MTTF) can be a good measure of reliability \cite{berander2005software}

\subsection{Robustness}
The degree to which a system or component can function correctly in the presence of invalid inputs or stressful environmental conditions \cite{IEEEStdGlossarySET1990}.
The quality can be further informally refined as the ability of a software to keep an acceptable behavior, expressed in terms of robustness requirements, in spite of exceptional or unforeseen execution conditions (such as the unavailability of system resources, communication failures, invalid or stressful inputs, etc.) \cite{fernandez2005model}.

\subsection{Performance}

The degree to which a system or component accomplishes its designated functions
within given constraints, such as speed, accuracy, or memory usage
\cite{IEEEStdGlossarySET1990}.  Performance considerations can make
certification challenging, since QA becomes more difficult for more complex
code.  However, as Roache~\cite[p.~355]{Roache1998} points out, using simpler
algorithms and reducing the number of options in general purpose code, is not
always a practical option.

\subsection{Usability}

ISO defines usability as
\begin{quote}
The extent to which a product can be used by specified users to achieve
specified goals with effectiveness, efficiency, and satisfaction in a specified
context of use.
\end{quote}

Nielsen and (separately) Schneidermann have defined usability as part of usefulness and
is composed of
\begin{itemize}
\item Learnability: How easy is it for users to accomplish basic tasks the
  first time they encounter the design?
\item Efficiency: Once users have learned the design, how quickly can they perform tasks?
\item Memorability: When users return to the design after a period of not using
  it, how easily can they re-establish proficiency?
\item Errors: How many errors do users make, how severe are these errors, and
  how easily can they recover from the errors?
\item Satisfaction: How pleasant is it to use the design?
\end{itemize}
In that context, it makes sense to separate \emph{usefulness} into
\emph{usability} (purely an interface concern) and \emph{utility} (in the economics
sense of the word).

There are two ISO standards covering this, namely ISO/TR 16982:202 and ISO 9241. 

The Interaction Design Foundation~\url{https://www.interaction-design.org/literature/topics/usability}
further lists the following desirable outcomes:
\begin{enumerate}
\item It should be easy for the user to become familiar with and competent in using
the user interface during the first contact with the website. For example, if a
travel agent’s website is a well-designed one, the user should be able to move
through the sequence of actions to book a ticket quickly.
\item It should be easy for users to achieve their objective through using the
website. If a user has the goal of booking a flight, a good design will guide
him/her through the easiest process to purchase that ticket.
\item It should be easy to recall the user interface and how to use it on
subsequent visits. So, a good design on the travel agent’s site means the user
should learn from the first time and book a second ticket just as easily.
\end{enumerate}

One core reference, for definitions and metrics, is Bevan~\cite{bevan1995measuring}.

\subsection{Maintainability}

The ease with which a software system or component can be modified to correct faults, improve performance or other attributes, or adapt to a changed environment \cite{IEEEStdGlossarySET1990}. ISO/IEC 25010 refers to maintainability as the degree of effectiveness and efficiency with which a product or system can be modified by the intended maintainers \cite{ISO/IEC25010}.
Maintainability is necessary in scientific software, since change, through iteration, experimentation and exploration, is inevitable.  Models of physical phenomena and numerical techniques necessarily evolve over time~\cite{CarverEtAl2007, SegalAndMorris2008}.  Proper documentation, designed with change in mind, can greatly assist with change management.  QA activities need to take the need for creativity into account, while not smothering
it~\cite[p.~352]{Roache1998}.

\subsection{Reusability}

The degree to which a software module or other work product can be used in more than one software system \cite{IEEEStdGlossarySET1990}. Reusability provides support for the quality of reliability, since reliability
is improved by reusing trusted components~\cite{Dubois2005}.  (Care must still
be taken with reusing trusted components, since blind reuse in a new context can lead to errors, as dramatically shown in the Ariane 5 disaster~\cite[p.~37--38]{OliveiraAndStewart2006}.)  The odds of reuse are improved when it is considered right from the start.

\subsection{Portability}

The ease with which a system or component can be transferred from one hardware or software environment to another \cite{IEEEStdGlossarySET1990}. An application is portable across a class of environments to the degree that the effort required to transport and adapt it to a new environment in the class is less than the effort of redevelopment \cite{mooney1990strategies}.
 

\subsection{Understandability}

Understandability is artifact-dependent. What it means for a user-interface (graphical
or otherwise) to be understandable is wildly different than what it means for the code,
and even the user documentation.

The literature here is thin and scattered.  More work will need to be done to find
something useful.

Interestingly, the business literature seems to have taken more care to define this.
Here we encounter
\begin{quote}
Understandability is the concept that X should be presented
so that a reader can easily comprehend it.
\end{quote}
At least this brings in the idea that the \emph{reader} is actively involved, and
indirectly that the reader's knowledge may be relevant, as well as the
``clarity of exposition'' of X.

Section 11.2 of~\cite{adams2015nonfunctional} does have a full definition.

\subsection{Interoperability}

\begin{quotation}
	\noindent Interoperability is the ability of two or more systems or components to exchange information and to use the information that has been exchanged~\cite{IEEE1991}.
	\noindent The degree to which two or more systems, products or components can exchange information and use the information that has been exchanged~\cite{ISO/IEC25010}.
	\noindent The capability to communicate, execute programs, and transfer data among various functional units in a manner that requires the user to have little or no knowledge of the unique characteristics of those units~\cite{ISO/IEC/IEEE24765}.
	\noindent Interoperability is a characteristic of a product or system, whose interfaces are completely understood, to work with other products or systems, present or future, in either implementation or access, without any restrictions~\cite{AFUL}.
\end{quotation}

\subsection{Visibility/Transparency}
    \ad{I found little contents related to visibility or transparency. The following definition is the only one I could find, but may be irrelevant to this project.}
    \begin{quotation}
        1. the degree to which a transaction can access object state concurrently with other transactions. 2. the specification, for a property, of "who can see it?"~\cite{ISO/IEC/IEEE24765}
    \end{quotation}
    
\subsection{Reproducibility}

Reproducibility is a required component of the scientific
method~\cite{Davison2012}.  Although QA has, ``a bad name among creative
scientists and engineers''~\cite[p.~352]{Roache1998}, the community need to
recognize that participating in QA management also improves reproducibility.
Reproducibility, like QA, benefits from a consistent and repeatable computing
environment, version control and separating code from
configuration/parameters~\cite{Davison2012}.

Reproducibility is defined as:

A result is said to be reproducible if another researcher can take the original
code and input data, execute it, and re-obtain the same result (Peng, Dominici,
and Zeger, 2006), as cited in \citet{BenureauAndRougier2017}.

The related concept of replicable is defined as:

Documentation achieves replicability if the description it provides of the
algorithms is sufficiently precise and complete for an independent researcher to
re-obtain the results it presents.  \citep{BenureauAndRougier2017}

It would be worthwhile to look for some additional definitions.

\subsection{Productivity}

\begin{quotation}
    The best definition of the productivity of a process is
    \[\text{Productivity} = \dfrac{\text{Outputs produced by the
          process}}{\text{Inputs consumed by the process}}\]
    Defining inputs. For the software process, providing a meaningful definition
    of inputs is a nontrivial but generally workable problem. Inputs to the
    software process generally comprise labor, computers, supplies, and other
    support facilities and equipment. Defining outputs. The big problem in
    defining software productivity is defining outputs. Here we find a
    paradox. Most sources say that defining delivered source instructions (DSI)
    or lines of code as the output of the software process is totally
    inadequate, and they argue that there are a number of deficiencies in using
    DSI. However, most organizations doing practical productivity measurement
    still use DSI as their primary metric~\cite{Boehm1987}.

    \smallskip
    Productivity is the amount of output (what is produced) per unit of input used.If we can measure the size of the software product and the effort required to develop the product, we have:
    \begin{align}
        \text{productivity} = \text{size}/\text{effort}
    \end{align}
    Equation (1) assumes that size is the output of the software production
    process and effort is the input to the process. This can be contrasted with
    the viewpoint of software cost models where we use size as an independent
    variable (i.e., an input) to predict effort which is treated as an
    output. Equation (1) is simple to operationalize if we have a single
    dominant size measure, for example, product size measured in lines of
    code~\cite{Kitchenham2004}.
\end{quotation}

\subsection{Sustainability}

One of the original definitions of sustainability (for systems, not software
specific), and still often quoted, is:

\begin{quotation}
\noindent The ability to meet the needs of the present without compromising the ability of
future generations to meet their own needs \cite{Brundtland1987}.
\end{quotation}

This is the definition used by~\cite{IISD2019}.

To make it more useful, this definition is often split into three dimensions:
social, economic and environmental. \wss{cite UN paper [9] in
  \cite{PenzenstadlerAndHenning2013}}  To this list Penzenstadler and Henning
(2013) have added technical sustainability \cite{PenzenstadlerAndHenning2013}.
Where technical sustainability for software is defined as:

\begin{quotation}
\noindent Technical sustainability has the central objective of long-time
usage of systems and their adequate evolution with changing surrounding
conditions and respective requirements \cite{PenzenstadlerAndHenning2013}.
\end{quotation}

The fourth dimension of technical sustainability is also added
by~\cite{WolframEtAl2017}.  Technical sustainability is the focus on the thesis
by~\cite{Hygerth2016}.

\begin{quotation}
  \noindent Sustainable development is a mindset (principles) and an
  accompanying set of practices that enable a team to achieve and maintain an
  optimal development pace indefinitely~\cite{Tate2005}.
\end{quotation}

Parnas discusses as software aging~\cite{Parnas1994a}.

SCS specific definitions:

\begin{quotation}
  \noindent The concept of sustainability is based on three pillars: the
  ecological, the economical and the social. This means that for a software to
  be sustainable, we must take all of its effects -- direct and indirect -- on
  the environment, the economy and the society into account. In addition, the
  entire life cycle of a software has to be considered: from planning and
  conception to programming, distribution, installation, usage and
  disposal~\cite{Heine2017}.
\end{quotation}

\begin{quotation}
  \noindent The capacity of the software to endure. In other words,
  sustainability means that the software will continue to be available in the
  future, on new platforms, meeting new needs~\cite{Katz2016}.
\end{quotation}

Definition from Neil Chue Hong:
\begin{quotation}
\noindent Sustainable software is software which is:
-- Easy to evolve and maintain
-- Fulfils its intent over time
-- Survives uncertainty
-- Supports relevant concerns (Political, Economic, Social, Technical,
Legal, Environmental)~\cite{Katz2016}.
\end{quotation}

Paper critical of a lack of a definition~\cite{VentersEtAl2014}.

Sounds like definition of maintainability.

Find paper that combines nonfunctional qualities into sustainability.

Sustainability depends on the software artifacts AND the software team AND the
development process.

\section{Desirable Qualities of Good Specifications} \label{SecDesirableQs}

To achieve the qualities listed in Section~\ref{SecQualities}, the documentation
should achieve the qualities listed in this section.  All but the final quality
listed (abstraction), are adapted from the IEEE recommended practise for
producing good software requirements~\cite{IEEE1998}.  Abstraction means only
revealing relevant details, which in a requirements document means stating what
is to be achieved, but remaining silent on how it is to be achieved.
Abstraction is an important software development principle for dealing with
complexity~\cite[p.~40]{GhezziEtAl2003}.  Correctness was in the above list, so
it is not repeated here.  \citet{SmithAndKoothoor2016} present further details
on the qualities of documentation for SCS.

\subsection{Completeness}

Documentation is said to be complete when all the requirements of the software
are detailed. That is, each goal, functionality, attribute, design constraint,
value, data, model, symbol, term (with its unit of measurement if applicable),
abbreviation, acronym, assumption and performance requirement of the software is
defined.  The software's response to all classes of inputs, both valid and
invalid and for both desired and undesired events, also needs to be specified.

\begin{quotation}
    A specification is complete to the extent that all of its parts are present and each part is fully developed. A software specification must exhibit several properties to assure its completeness:
    \begin{itemize}
        \item No TBDs. TBDs are places in the specification where decisions have been postponed by writing "To be Determined" or "TBD."
        \item No nonexistent references. These are references in the specification to functions, inputs, or outputs (including databases) not defined in the specification.
        \item No missing specification items. These are items that should be present as part of the standard format of the specification, but are not present.
        \item No missing functions. These are functions that should be part of the software product but are not called for in the specification.
        \item No missing products. These are products that should be part of the delivered software but are not called for in the specification.~\cite{Boehm1984}.
    \end{itemize}

\end{quotation}

\subsection{Consistency}

Documentation is said to be consistent when no subset of individual statements
are in conflict with each other. That is, a specification of an item made at one
place in the document should not contradict the specification of the same item
at another location.

\begin{quotation}
    A specification is consistent to the extent that its provisions do not conflict with each other or with governing specifications and objectives. Specifications require consistency in several ways.
    \begin{itemize}
        \item Internal consistency. Items within the specification do not conflict with each other.
        \item External consistency. Items in the specification do not conflict with external specifications or entities.
        \item Traceability. Items in the specification have clear antecedents in earlier specifications or statements of system objectives~\cite{Boehm1984}.
    \end{itemize}
    Consistency requires that no two or more requirements in a specification contradict each other. It is also often regarded as the case where words and terms have the same meaning throughout the requirements specifications (consistent use of terminology). These two views of consistency imply that mutually exclusive statements and clashes in terminology should be avoided~\cite{ZOWGHI2003}. Consistency: 1. the degree of uniformity, standardization, and freedom from contradiction among the documents or parts of a system or component 2. software attributes that provide uniform design and implementation techniques and notations~\cite{ISO/IEC/IEEE24765}
\end{quotation}

\subsection{Modifiability}

Here we do seem to have a simple, if somewhat uninformative, definition:

\begin{defn}
Modifiability is the degree of ease at which changes can be made to a system,
and the flexibility with which the system adapts to such changes.
\end{defn}

IEEE Standard 610 seems to speak about this. (which is superceded?)

\subsection{Traceability}

Here the Wikipedia page~\url{https://en.wikipedia.org/wiki/Traceability} is actually
rather informative, especially as it also lists how this concept is used in other domains.
A generic definition that is still quite useful is
\begin{defn}
The capability (and implementation) of keeping track of a given set or type of
information to a given degree, or the ability to chronologically interrelate
uniquely identifiable entities in a way that is verifiable.
\end{defn}
By specializing the above to software artifacts, ``interrelate'' to 
``why is this here'' (for forward tracing from requirements), this does
indeed give what is meant in SE.

Various standards (DO178C, ISO 26262, and IEC61508) explicitly mention it.

24765-2017 - ISO/IEC/IEEE International Standard - Systems and software engineering--Vocabulary
has a full definition, namely
\begin{enumerate}
\item the degree to which a relationship can be established between two or more
products of the development process, especially products having a
predecessor-successor or master-subordinate relationship to one another;
\item
the identification and documentation of derivation paths (upward) and
allocation or flowdown paths (downward) of work products in the work product
hierarchy;
\item the degree to which each element in a software development
product establishes its reason for existing; and discernible association
among two or more logical entities, such as requirements, system elements,
verifications, or tasks.
\end{enumerate}

\subsection{Unambiguity}

A specification is unambiguous when it has a unique interpretation.  If there is
a possibility that two readers will have two different interpretations, than the
specification is ambiguous.  \wss{When I get the Ghezzi text back from Olu, I'll
  check to see if they have anything to add to this definition.}

A Software Requirements Specification (SRS) is unambiguous if, and only if,
every requirement stated therein has only one interpretation \citep{IEEE1998}.

\subsection{Verifiability}

\begin{itemize}

\item Verification - Are we building the product right?  Are we implementing the
  requirements correctly (internal)
\item Validation - Are we building the right product? Are we getting the right
  requirements (external)
\item According to
  \href{https://en.wikipedia.org/wiki/Software_verification_and_validation}{Capability
    Maturity Model (CMM)}
\begin{itemize}
\item 
    Software Verification: The process of evaluating software to determine
    whether the products of a given development phase satisfy the conditions
    imposed at the start of that phase. [IEEE-STD-610]
  \item Software Validation: The process of evaluating software during or at the
    end of the development process to determine whether it satisfies specified
    requirements. [IEEE-STD-610] 
\end{itemize}
\end{itemize}

``An SRS is verifiable if, and only if, every requirement stated therein is
verifiable. A requirement is verifiable if, and only if, there exists some
finite cost-effective process with which a person or machine can check that the
software product meets the requirement. In general any ambiguous requirement is
not verifiable.'' \citep{IEEE1998}

Verifiability is related to testability, which is defined by McCall et al.\ as
``The effort required to test a program to ensure that it performs its intended
function'' \cite{VanVliet2000}.  

\wss{When I get the Ghezzi text back from Olu,
  I'll check to see if they have anything to add to this definition.}

\subsection{Abstract}

Documented requirements are said to be abstract if they state what the software
must do and the properties it must possess, but do not speak about how these are
to be achieved \citep{GhezziEtAl2003}.  

``An abstraction for a software artifact is a succinct description that suppresses
the details that are unimportant to a software developer and emphasizes the
information that is important.'' \cite{Krueger1992}

``Abstraction means that we concentrate on the essential features and ignore,
abstract from, details that are not relevant at the level we are currently
working.''  \cite[p.\ 296]{VanVliet2000}

``Abstraction in mathematics is the process of extracting the underlying essence
of a mathematical concept, removing any dependence on real world objects with
which it might originally have been connected, and generalizing it so that it
has wider applications or matching among other abstract descriptions of
equivalent phenomena.''
\href{https://en.wikipedia.org/wiki/Abstraction_(mathematics)} {Wikipedia
  Definition}

Abstraction is related to reusability (and other qualities).

\wss{When I get the Ghezzi text back from Olu, I'll check to see if they have
  anything to add to this definition.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../CommonFiles/ResearchProposal}

\end{document}
