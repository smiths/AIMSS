\documentclass[letterpaper,cleveref]{lipics-v2019}

\usepackage{natbib}
\usepackage{booktabs}
\usepackage{amsmath,amsthm}
\usepackage{hyperref}

\usepackage{hyperref}
\hypersetup{
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with
%linkbordercolor)
citecolor=blue,       % color of links to bibliography
filecolor=magenta,   % color of file links
urlcolor=cyan           % color of external links
}

%% Comments
\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\wss}[1]{\authornote{blue}{SS}{#1}} %Spencer Smith
\newcommand{\jc}[1]{\authornote{red}{JC}{#1}} %Jacques Carette
\newcommand{\oo}[1]{\authornote{magenta}{OO}{#1}} %Olu Owojaiye
\newcommand{\pmi}[1]{\authornote{green}{PM}{#1}} %Peter Michalski
\newcommand{\ad}[1]{\authornote{cyan}{AD}{#1}} %Ao Dong

\newcommand{\notdone}[1]{\textcolor{red}{#1}}
\newcommand{\done}[1]{\textcolor{black}{#1}}

%\oddsidemargin 0mm
%\evensidemargin 0mm
%\textwidth 160mm
%\textheight 200mm

\theoremstyle{definition}
\newtheorem{defn}{Definition}

\title{Experiments} 
\author{Spencer Smith}{McMaster University, Canada}{smiths@mcmaster.ca}{}{}
\author{Jacques Carette}{McMaster University, Canada}{carette@mcmaster.ca}{}{}
\author{Olu Owojaiye}{McMaster University, Canada}{owojaiyo@mcmaster.ca}{}{}
\author{Peter Michalski}{McMaster University, Canada}{michap@mcmaster.ca}{}{}
\author{Ao Dong}{McMaster University, Canada}{donga9@mcmaster.ca}{}{}

\authorrunning{Smith et al.}  \Copyright{Spencer Smith and Jacques Carette and
Olu Owojaiye and Peter Michalski and Ao Dong}

\date{\today}

\hideLIPIcs
\nolinenumbers

\begin{document}
\maketitle

~\newpage
\section{User Experiments}
\subsection{Usability Experimental Procedure}

\subsection {Procedure}
\begin {enumerate}
%\item Select a list of projects
%\item Write research questions
%\item Prepare logistic details(location, time table, recording setup, moderators etc)
%\item Prepare survey questions
%\item Design the tasks for the study subjects to perform (tasks can be defined based on user category, at least one task to modify the software)
%\item Select participants

\item Survey participants to collect pre-experiment data
\item Participants perform tasks
\item Observe the study subjects (take notes, record sessions(OBS screen recorder), watch out for body languages and verbal cues)
\item Survey the study subjects to collect feedback (post experiment interview)
\item Prepare experiment report
\item Perform pairwise comparison analysis
\item Prepare analysis report
\end {enumerate}


%\subsection{Nielsen’s Heuristics}
%\begin{enumerate}
%	\item Consistency: Check if standards and conventions in product design are followed
% \begin{itemize}
% 	\item Sequences of actions (skill acquisition).
% 	\item Color (categorization).
% 	\item Layout and position (spatial consistency).
% 	\item Font, capitalization (levels of organization).
% 	\item Terminology (delete, del, remove, rm) and language (words, phrases).
% 	\item Standards (e.g.,	blue underlined text for unvisited hyper links).
% \end{itemize}
%\item Visibility: Users should be informed about what is going on with the system through appropriate feedback and display of information e.g. 
% \begin{itemize}
% \item What is the current state of the system?
% \item What can be done at current state?
% \item Where can users go?
% \item What change is made after an action?
% \end{itemize}
%\item Match between system and world. The image of the system perceived by users should match the model the users have about the system. 
%\begin {itemize}
%\item User model matches system image.
%\item Actions provided by the system should match actions performed by users.
%\item Objects on the system should match objects of the task.
%\end {itemize}
%\item Minimalist: Any extraneous information is a distraction and a slow-down. 
%\begin{itemize}
%\item Less is more.
%\item Simple is not equivalent to abstract and general.
%\item Simple is efficient.
%\item  Progressive levels of detail.
%\end{itemize}
%\item Minimize memory load. Users should not be required to memorize a lot of information to carry out tasks. Memory load reduces users’ capacity to carry out the main tasks. 
%\begin{itemize}
%\item Recognition vs. recall (e.g., menu vs. commands).
%\item Externalize information through visualization.
%\item Perceptual procedures.
%\item Hierarchical structure.
%\item Default values.
%\item Concrete examples (DD/MM/YY, e.g., 10/20/99).
%\item Generic rules and actions (e.g., drag objects).
%\item Intuitive procedure
%\end{itemize}
%\item Informative feedback. Users should be given prompt and informative feedback about their actions. 
%\begin{itemize}
%\item Information that can be directly perceived, interpreted, and evaluated.
%\item Levels of feedback (novice and expert).
%\item Concrete and specific, not abstract and general.
%\item Response time:\\
%-0.1 s for instantaneously reacting;\\
%-1.0 s for uninterrupted flow of thought;\\
%-10 s for the limit of attention.
%\end{itemize}
%%\item Flexibility and efficiency. Users always learn and users are always different. Give users the flexibility of creating customization and shortcuts to accelerate their performance. 
%%\begin{itemize}
%%	\item Shortcuts for experienced users.
%%	\item Shortcuts or macros for frequently used operations.
%%	\item Skill acquisition through chunking.
%%	\item Examples:
%%	- Abbreviations, function keys, hot keys, command keys, macros, aliases, templates, type-ahead, bookmarks, hot links, history, default values, etc.
%%\end{itemize}
%\item Good error messages. 
%\begin {itemize}
%\item The messages should be informative enough such that users can understand the nature of errors, learn from errors, and recover from errors. 
%\item Phrased in clear language, avoid obscure codes. Example of obscure code: “system crashed, error code 147.”
%\item Precise, not vague or general. Example of general comment: “Cannot open document.”
%\item Constructive.
%\item Polite. Examples of impolite message: “illegal user action,” “job aborted,” “system was crashed,” “fatal error,” etc.
%\end {itemize}
%\item Prevent errors. It is always better to design interfaces that prevent errors from happening in the first place.
%\begin {itemize} 
%\item Interfaces that make errors impossible.
%\item Avoid modes (e.g., vi, text wrap). Or use informative feedback, e.g., different sounds.
%\item Execution error vs. evaluation error.
%\item Various types of slips and mistakes.
%\end {itemize}
%\item Clear closure. Every task has a beginning and an end. Users should be clearly notified about the completion of a task. 
%\begin {itemize}
%\item Clear beginning, middle, and end.
%\item Complete 7-stages of actions.
%\item Clear feedback to indicate goals are achieved and current stacks of goals can be released. Examples of good closures include many dialogues.
%\end {itemize}
%\item Reversible actions. 
%\begin {itemize}
%\item Users should be allowed to recover from errors. Reversible actions also encourage exploratory learning. 
%\item At different levels: a single action, a subtask, or a complete task.
%\item Multiple steps.
%\item Encourage exploratory learning.
%\item Prevent serious errors.
%\end {itemize}
%\item Use users’ language. The language should be always presented in a form understandable by the intended users.
%\begin{itemize}
%\item Use standard meanings of words.
%\item Specialized language for specialized group.
%\item User defined aliases.
%\item Users’ perspective. Example: “we have bought four tickets for you” (bad) vs. “you bought four tickets” (good).
%\end {itemize}
%\item Help and documentation. Always provide help when needed. 
%\begin {itemize}
%\item Context-sensitive help.
%\item Four types of help.\\
%-task-oriented;\\
%-alphabetically ordered;\\
%-semantically organized;\\
%-search.
%\item Help embedded in contents.
%\end {itemize}
%\item Users in control. Do not give users that impression that they are controlled by the systems. 
%\begin {itemize}
%\item Users are initiators of actors, not responders to actions.
%\item Avoid surprising actions, unexpected outcomes, tedious sequences of actions, etc.
%\end {itemize}
%\end{enumerate}

\subsection{Task selection criteria}
**The task selection will be determined with the aid of the domain experts attached to any of the selected projects.\\ 
**The domain experts will be asked to consider the below criteria when defining a task. \\
**Domain experts will also be asked to identify what background knowledge is necessary for the suggested tasks - Novice, Intermediate, Advanced
\begin {enumerate}
\item Collectively all tasks should not take no more than 2 hours.
\item Selected tasks should reflect common use cases of  the software.
\item Include tasks that require a set of sequential or hierarchical steps to be completed 

\end {enumerate} 


\subsection{Usability Questionnaire}
Two sources of standardized usability questionnaire we could use.

- \url{https://www.usabilitest.com/sus-pdf-generator}- 20-29 - SUS.\\
- \url{https://uiuxtrend.com/pssuq-post-study-system-usability-questionnaire/} - PSSUQ


~\newpage
\section{Modifiability Experiments}
\pmi{add preamble here describing some of the notes below}

What can be done to measure modifiability?

Idea: measure sensible changes

Can we measure sensible changes? How?

We could gather qualitative data about the process of attempting to make sensible changes. Perceived difficulty, available documentation, prerequisite knowledge, time/effort required, tools required, errors and issues encountered and ability to overcome those issues with the available resources, is there dev support? How to interpret results?

What does a small change mean? What are likely changes - See Parnas

Parnas identifies likely changes as:

 Likely Changes: if the system is required to be easy to change, the requirements should  contain  a  definition  of  the  areas  that  are  considered  likely  to  change.  You  cannot design a system so that everything is equally easy to change. Programmers should not have to decide which changes are most likely\cite{parnas1986rational}

We want to be explicit about what we want to modify.


\subsection {Procedure}
\begin{enumerate}
	\item Identify likely changes using procedure x
	\item Select from likely change list (using what criteria)
	\item Gather relevant documentation?
	\item Ask the domain expert to make the (selected) likely change(s)
	\item Have the domain expert answer a questionnaire about their attempt to make the likely change
\end{enumerate}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../CommonFiles/ResearchProposal}

\end{document}